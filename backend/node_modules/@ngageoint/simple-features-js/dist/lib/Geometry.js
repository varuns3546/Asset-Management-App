"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Geometry = void 0;
var internal_1 = require("./internal");
/**
 * The root of the geometry type hierarchy
 */
var Geometry = /** @class */ (function () {
    /**
     * Constructor
     * @param geometryType geometry type
     * @param hasZ has z
     * @param hasM has m
     */
    function Geometry(geometryType, hasZ, hasM) {
        this._geometryType = geometryType;
        this._hasZ = hasZ;
        this._hasM = hasM;
    }
    Object.defineProperty(Geometry.prototype, "geometryType", {
        /**
         * Get the geometry type
         * @return geometry type
         */
        get: function () {
            return this._geometryType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "hasZ", {
        /**
         * Does the geometry have z coordinates
         * @return true if has z coordinates
         */
        get: function () {
            return this._hasZ;
        },
        /**
         * Set if the geometry has z coordinates
         * @param hasZ true if has z coordinates
         */
        set: function (hasZ) {
            this._hasZ = hasZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "is3D", {
        /**
         * Does the geometry have z coordinates
         * @return true if has z coordinates
         * @see #hasZ()
         */
        get: function () {
            return this.hasZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Geometry.prototype, "hasM", {
        /**
         * Does the geometry have m coordinates
         * @return true if has m coordinates
         */
        get: function () {
            return this._hasM;
        },
        /**
         * Set if the geometry has m coordinates
         * @param hasM true if has m coordinates
         */
        set: function (hasM) {
            this._hasM = hasM;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Update currently false hasZ and hasM values using the provided geometry
     * @param geometry  geometry
     */
    Geometry.prototype.updateZM = function (geometry) {
        if (!this.hasZ) {
            this.hasZ = geometry.hasZ;
        }
        if (!this.hasM) {
            this.hasM = geometry.hasM;
        }
    };
    /**
     * Determine if the geometries contain a Z value
     * @param geometries list of geometries
     * @return true if has z
     */
    Geometry.hasZ = function (geometries) {
        var e_1, _a;
        var hasZ = false;
        try {
            for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
                var geometry = geometries_1_1.value;
                if (geometry.hasZ) {
                    hasZ = true;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (geometries_1_1 && !geometries_1_1.done && (_a = geometries_1.return)) _a.call(geometries_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return hasZ;
    };
    /**
     * Determine if the geometries contain a M value
     * @param geometries list of geometries
     * @return true if has m
     */
    Geometry.hasM = function (geometries) {
        var e_2, _a;
        var hasM = false;
        try {
            for (var geometries_2 = __values(geometries), geometries_2_1 = geometries_2.next(); !geometries_2_1.done; geometries_2_1 = geometries_2.next()) {
                var geometry = geometries_2_1.value;
                if (geometry.hasM) {
                    hasM = true;
                    break;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (geometries_2_1 && !geometries_2_1.done && (_a = geometries_2.return)) _a.call(geometries_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return hasM;
    };
    /**
     * Does the geometry have m coordinates.
     * @return true if has m coordinates
     * @see #hasM()
     */
    Geometry.prototype.isMeasured = function () {
        return this.hasM;
    };
    /**
     * Get the minimum bounding box for this Geometry
     * @return geometry envelope
     */
    Geometry.prototype.getEnvelope = function () {
        return internal_1.GeometryEnvelopeBuilder.buildEnvelope(this);
    };
    /**
     * Expand the envelope with the minimum bounding box for this Geometry
     * @param envelope geometry envelope to expand
     */
    Geometry.prototype.expandEnvelope = function (envelope) {
        internal_1.GeometryEnvelopeBuilder.buildEnvelopeWithEnvelope(this, envelope);
    };
    /**
     * Get the inherent dimension (0, 1, or 2) for this Geometry
     * @return dimension
     */
    Geometry.prototype.getDimension = function () {
        return internal_1.GeometryUtils.getDimension(this);
    };
    /**
     * Get the mathematical centroid point of a 2 dimensional representation of
     * the Geometry (balancing point of a 2d cutout of the geometry). Only the x
     * and y coordinate of the resulting point are calculated and populated. The
     * resulting {@link Point#getZ()} and {@link Point#getM()} methods will
     * always return null.
     * @return centroid point
     */
    Geometry.prototype.getCentroid = function () {
        return internal_1.GeometryUtils.getCentroid(this);
    };
    /**
     * Get the geographic centroid point of a 2 dimensional representation of
     * the degree unit Geometry. Only the x and y coordinate of the resulting
     * point are calculated and populated. The resulting {@link Point#getZ()}
     * and {@link Point#getM()} methods will always return null.
     * @return centroid point
     */
    Geometry.prototype.getDegreesCentroid = function () {
        return internal_1.GeometryUtils.getDegreesCentroid(this);
    };
    Geometry.prototype.equals = function (obj) {
        return !(this.geometryType !== obj.geometryType || this.hasM !== obj.hasM || this.hasZ !== obj.hasZ);
    };
    return Geometry;
}());
exports.Geometry = Geometry;
//# sourceMappingURL=Geometry.js.map