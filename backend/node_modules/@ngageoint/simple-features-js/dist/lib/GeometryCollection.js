"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryCollection = void 0;
var internal_1 = require("./internal");
/**
 * A collection of zero or more Geometry instances.
 * @param <T> geometry type
 */
var GeometryCollection = /** @class */ (function (_super) {
    __extends(GeometryCollection, _super);
    /**
     * Constructor
     */
    function GeometryCollection() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = this;
        if (args.length === 0) {
            _this = _super.call(this, internal_1.GeometryType.GEOMETRYCOLLECTION, false, false) || this;
            _this._geometries = [];
        }
        else if (args.length === 2) {
            _this = _super.call(this, internal_1.GeometryType.GEOMETRYCOLLECTION, args[0], args[1]) || this;
            _this._geometries = [];
        }
        else if (args.length === 1 && args[0].length != null) {
            _this = _super.call(this, internal_1.GeometryType.GEOMETRYCOLLECTION, internal_1.Geometry.hasZ(args[0]), internal_1.Geometry.hasM(args[0])) || this;
            _this.geometries = args[0] || [];
        }
        else if (args.length === 1 && args[0] instanceof GeometryCollection) {
            _this = _super.call(this, internal_1.GeometryType.GEOMETRYCOLLECTION, args[0].hasZ, args[0].hasM) || this;
            _this._geometries = [];
            args[0].geometries.forEach(function (geometry) { return _this.addGeometry(geometry); });
        }
        else if (args.length === 1 && args[0] instanceof internal_1.Geometry) {
            _this = _super.call(this, internal_1.GeometryType.GEOMETRYCOLLECTION, args[0].hasZ, args[0].hasM) || this;
            _this._geometries = [];
            _this.addGeometry(args[0]);
        }
        else if (args.length === 3) {
            _this = _super.call(this, args[0], args[1], args[2]) || this;
            _this._geometries = [];
        }
        return _this;
    }
    Object.defineProperty(GeometryCollection.prototype, "geometries", {
        /**
         * Get the list of geometries
         * @return geometries
         */
        get: function () {
            return this._geometries;
        },
        /**
         * Set the geometries
         * @param geometries geometries
         */
        set: function (geometries) {
            var _this = this;
            this._geometries = [];
            geometries.forEach(function (geometry) { return _this.addGeometry(geometry); });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Add a geometry
     * @param geometry geometry
     */
    GeometryCollection.prototype.addGeometry = function (geometry) {
        this._geometries.push(geometry);
        this.updateZM(geometry);
    };
    /**
     * Add geometries
     * @param geometries geometries
     */
    GeometryCollection.prototype.addGeometries = function (geometries) {
        var _this = this;
        geometries.forEach(function (geometry) { return _this.addGeometry(geometry); });
    };
    /**
     * Get the number of geometries in the collection
     *
     * @return number of geometries
     */
    GeometryCollection.prototype.numGeometries = function () {
        return this._geometries.length;
    };
    /**
     * Returns the Nth geometry
     * @param n nth geometry to return
     * @return geometry
     */
    GeometryCollection.prototype.getGeometry = function (n) {
        return this._geometries[n];
    };
    /**
     * Get the collection type by evaluating the geometries
     * @return collection geometry type, one of: {@link GeometryType#MULTIPOINT},
     * 		   {@link GeometryType#MULTILINESTRING},
     *         {@link GeometryType#MULTIPOLYGON},
     *         {@link GeometryType#MULTICURVE},
     *         {@link GeometryType#MULTISURFACE},
     *         {@link GeometryType#GEOMETRYCOLLECTION}
     */
    GeometryCollection.prototype.getCollectionType = function () {
        var geometryType = this.geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.MULTIPOINT:
            case internal_1.GeometryType.MULTILINESTRING:
            case internal_1.GeometryType.MULTIPOLYGON:
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                if (this.isMultiPoint()) {
                    geometryType = internal_1.GeometryType.MULTIPOINT;
                }
                else if (this.isMultiLineString()) {
                    geometryType = internal_1.GeometryType.MULTILINESTRING;
                }
                else if (this.isMultiPolygon()) {
                    geometryType = internal_1.GeometryType.MULTIPOLYGON;
                }
                else if (this.isMultiCurve()) {
                    geometryType = internal_1.GeometryType.MULTICURVE;
                }
                else if (this.isMultiSurface()) {
                    geometryType = internal_1.GeometryType.MULTISURFACE;
                }
                break;
            default:
                throw new internal_1.SFException("Unexpected Geometry Collection Type: " + geometryType);
        }
        return geometryType;
    };
    /**
     * Determine if this geometry collection is a {@link MultiPoint} instance or
     * contains only {@link Point} geometries
     * @return true if a multi point or contains only points
     */
    GeometryCollection.prototype.isMultiPoint = function () {
        var isMultiPoint = this instanceof internal_1.MultiPoint;
        if (!isMultiPoint) {
            isMultiPoint = this.isCollectionOfType(internal_1.Point);
        }
        return isMultiPoint;
    };
    /**
     * Get as a {@link MultiPoint}, either the current instance or newly created
     * from the {@link Point} geometries
     *
     * @return multi point
     */
    GeometryCollection.prototype.getAsMultiPoint = function () {
        var multiPoint;
        if (this instanceof internal_1.MultiPoint) {
            multiPoint = this;
        }
        else {
            multiPoint = new internal_1.MultiPoint(this._geometries);
        }
        return multiPoint;
    };
    /**
     * Determine if this geometry collection is a {@link MultiLineString}
     * instance or contains only {@link LineString} geometries
     * @return true if a multi line string or contains only line strings
     */
    GeometryCollection.prototype.isMultiLineString = function () {
        var isMultiLineString = this instanceof internal_1.MultiLineString;
        if (!isMultiLineString) {
            isMultiLineString = this.isCollectionOfType(internal_1.LineString);
        }
        return isMultiLineString;
    };
    /**
     * Get as a {@link MultiLineString}, either the current instance or newly
     * created from the {@link LineString} geometries
     * @return multi line string
     */
    GeometryCollection.prototype.getAsMultiLineString = function () {
        var multiLineString;
        if (this instanceof internal_1.MultiLineString) {
            multiLineString = this;
        }
        else {
            multiLineString = new internal_1.MultiLineString(this._geometries);
        }
        return multiLineString;
    };
    /**
     * Determine if this geometry collection is a {@link MultiPolygon} instance
     * or contains only {@link Polygon} geometries
     * @return true if a multi polygon or contains only polygons
     */
    GeometryCollection.prototype.isMultiPolygon = function () {
        var isMultiPolygon = this instanceof internal_1.MultiPolygon;
        if (!isMultiPolygon) {
            isMultiPolygon = this.isCollectionOfType(internal_1.Polygon);
        }
        return isMultiPolygon;
    };
    /**
     * Get as a {@link MultiPolygon}, either the current instance or newly
     * created from the {@link Polygon} geometries
     *
     * @return multi polygon
     */
    GeometryCollection.prototype.getAsMultiPolygon = function () {
        var multiPolygon;
        if (this instanceof internal_1.MultiPolygon) {
            multiPolygon = this;
        }
        else {
            multiPolygon = new internal_1.MultiPolygon(this._geometries);
        }
        return multiPolygon;
    };
    /**
     * Determine if this geometry collection contains only {@link Curve}
     * geometries
     * @return true if contains only curves
     */
    GeometryCollection.prototype.isMultiCurve = function () {
        var isMultiCurve = this instanceof internal_1.MultiLineString;
        if (!isMultiCurve) {
            isMultiCurve = this.isCollectionOfType(internal_1.Curve);
        }
        return isMultiCurve;
    };
    /**
     * Get as a Multi Curve, a {@link Curve} typed Geometry Collection
     * @return multi curve
     */
    GeometryCollection.prototype.getAsMultiCurve = function () {
        var multiCurve;
        if (this instanceof internal_1.MultiLineString) {
            multiCurve = new GeometryCollection(this.geometries);
        }
        else {
            multiCurve = this;
            if (!multiCurve.isEmpty()) {
                var curve = multiCurve.getGeometry(0);
            }
        }
        return multiCurve;
    };
    /**
     * Determine if this geometry collection contains only {@link Surface}
     * geometries
     *
     * @return true if contains only surfaces
     */
    GeometryCollection.prototype.isMultiSurface = function () {
        var isMultiSurface = this instanceof internal_1.MultiPolygon;
        if (!isMultiSurface) {
            isMultiSurface = this.isCollectionOfType(internal_1.Surface);
        }
        return isMultiSurface;
    };
    /**
     * Get as a Multi Surface, a {@link Surface} typed Geometry Collection
     * @return multi surface
     */
    GeometryCollection.prototype.getAsMultiSurface = function () {
        var multiSurface;
        if (this instanceof internal_1.MultiPolygon) {
            multiSurface = new GeometryCollection(this.geometries);
        }
        else {
            multiSurface = this;
            if (!multiSurface.isEmpty()) {
                var surface = multiSurface.getGeometry(0);
            }
        }
        return multiSurface;
    };
    /**
     * Get as a top level Geometry Collection
     * @return geometry collection
     */
    GeometryCollection.prototype.getAsGeometryCollection = function () {
        return new GeometryCollection(this.geometries);
    };
    /**
     * Determine if the geometries in this collection are made up only of the
     * provided geometry class type
     * @param type geometry class type
     * @return true if a collection of the type
     */
    GeometryCollection.prototype.isCollectionOfType = function (type) {
        var isType = true;
        for (var i = 0; i < this._geometries.length; i++) {
            var geometry = this._geometries[i];
            if (!(geometry instanceof type)) {
                isType = false;
                break;
            }
        }
        return isType;
    };
    /**
     * {@inheritDoc}
     */
    GeometryCollection.prototype.copy = function () {
        return new GeometryCollection(this);
    };
    /**
     * {@inheritDoc}
     */
    GeometryCollection.prototype.isEmpty = function () {
        return this._geometries.length === 0;
    };
    /**
     * {@inheritDoc}
     */
    GeometryCollection.prototype.isSimple = function () {
        throw new internal_1.UnsupportedOperationException("Is Simple not implemented for GeometryCollection");
    };
    /**
     * {@inheritDoc}
     */
    GeometryCollection.prototype.equals = function (obj) {
        var equals = true;
        if (obj instanceof GeometryCollection && this.numGeometries() === obj.numGeometries()) {
            for (var i = 0; i < this.numGeometries(); i++) {
                if (!this.getGeometry(i).equals(obj.getGeometry(i))) {
                    equals = false;
                    break;
                }
            }
        }
        else {
            equals = false;
        }
        return equals;
    };
    return GeometryCollection;
}(internal_1.Geometry));
exports.GeometryCollection = GeometryCollection;
//# sourceMappingURL=GeometryCollection.js.map