"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryEnvelopeBuilder = void 0;
var internal_1 = require("../internal");
/**
 * Builds an envelope from a Geometry
 */
var GeometryEnvelopeBuilder = /** @class */ (function () {
    function GeometryEnvelopeBuilder() {
    }
    /**
     * Build Geometry Envelope
     * @param geometry geometry to build envelope from
     * @return geometry envelope
     */
    GeometryEnvelopeBuilder.buildEnvelope = function (geometry) {
        var envelope = new internal_1.GeometryEnvelope();
        envelope.minX = Number.MAX_VALUE;
        envelope.maxX = -Number.MAX_VALUE;
        envelope.minY = Number.MAX_VALUE;
        envelope.maxY = -Number.MAX_VALUE;
        GeometryEnvelopeBuilder.buildEnvelopeWithEnvelope(geometry, envelope);
        if (envelope.minX > envelope.maxX || envelope.minY > envelope.maxY) {
            envelope = null;
        }
        return envelope;
    };
    /**
     * Build Geometry Envelope
     * @param geometry geometry to build envelope from
     * @param envelope geometry envelope to expand
     */
    GeometryEnvelopeBuilder.buildEnvelopeWithEnvelope = function (geometry, envelope) {
        if (geometry instanceof internal_1.Point) {
            GeometryEnvelopeBuilder.addPoint(envelope, geometry);
        }
        else if (geometry instanceof internal_1.LineString) {
            GeometryEnvelopeBuilder.addLineString(envelope, geometry);
        }
        else if (geometry instanceof internal_1.Polygon) {
            GeometryEnvelopeBuilder.addPolygon(envelope, geometry);
        }
        else if (geometry instanceof internal_1.MultiPoint) {
            GeometryEnvelopeBuilder.addMultiPoint(envelope, geometry);
        }
        else if (geometry instanceof internal_1.MultiLineString) {
            GeometryEnvelopeBuilder.addMultiLineString(envelope, geometry);
        }
        else if (geometry instanceof internal_1.MultiPolygon) {
            GeometryEnvelopeBuilder.addMultiPolygon(envelope, geometry);
        }
        else if (geometry instanceof internal_1.CircularString) {
            GeometryEnvelopeBuilder.addLineString(envelope, geometry);
        }
        else if (geometry instanceof internal_1.CompoundCurve) {
            GeometryEnvelopeBuilder.addCompoundCurve(envelope, geometry);
        }
        else if (geometry instanceof internal_1.CurvePolygon) {
            GeometryEnvelopeBuilder.addCurvePolygon(envelope, geometry);
        }
        else if (geometry instanceof internal_1.PolyhedralSurface) {
            GeometryEnvelopeBuilder.addPolyhedralSurface(envelope, geometry);
        }
        else if (geometry instanceof internal_1.TIN) {
            GeometryEnvelopeBuilder.addPolyhedralSurface(envelope, geometry);
        }
        else if (geometry instanceof internal_1.Triangle) {
            GeometryEnvelopeBuilder.addPolygon(envelope, geometry);
        }
        else if (geometry instanceof internal_1.GeometryCollection || geometry instanceof internal_1.MultiCurve || geometry instanceof internal_1.MultiSurface) {
            GeometryEnvelopeBuilder.updateHasZandM(envelope, geometry);
            var geometries = geometry.geometries;
            geometries.forEach(function (subGeometry) {
                GeometryEnvelopeBuilder.buildEnvelopeWithEnvelope(subGeometry, envelope);
            });
        }
    };
    /**
     * Update the has z and m values
     * @param envelope geometry envelope
     * @param geometry geometry
     */
    GeometryEnvelopeBuilder.updateHasZandM = function (envelope, geometry) {
        if (!envelope.hasZ && geometry.hasZ) {
            envelope.hasZ = true;
        }
        if (!envelope.hasM && geometry.hasM) {
            envelope.hasM = true;
        }
    };
    /**
     * Add Point
     * @param envelope geometry envelope
     * @param point point
     */
    GeometryEnvelopeBuilder.addPoint = function (envelope, point) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, point);
        var x = point.x;
        var y = point.y;
        if (x < envelope.minX) {
            envelope.minX = x;
        }
        if (x > envelope.maxX) {
            envelope.maxX = x;
        }
        if (y < envelope.minY) {
            envelope.minY = y;
        }
        if (y > envelope.maxY) {
            envelope.maxY = y;
        }
        if (point.hasZ) {
            var z = point.z;
            if (z != null) {
                if (envelope.minZ == null || z < envelope.minZ) {
                    envelope.minZ = z;
                }
                if (envelope.maxZ == null || z > envelope.maxZ) {
                    envelope.maxZ = z;
                }
            }
        }
        if (point.hasM) {
            var m = point.m;
            if (m != null) {
                if (envelope.minM == null || m < envelope.minM) {
                    envelope.minM = m;
                }
                if (envelope.maxM == null || m > envelope.maxM) {
                    envelope.maxM = m;
                }
            }
        }
    };
    /**
     * Add MultiPoint
     * @param envelope geometry envelope
     * @param multiPoint multi point
     */
    GeometryEnvelopeBuilder.addMultiPoint = function (envelope, multiPoint) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, multiPoint);
        multiPoint.points.forEach(function (point) { return GeometryEnvelopeBuilder.addPoint(envelope, point); });
    };
    /**
     * Add LineString
     * @param envelope geometry envelope
     * @param lineString line string
     */
    GeometryEnvelopeBuilder.addLineString = function (envelope, lineString) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, lineString);
        lineString.points.forEach(function (point) { return GeometryEnvelopeBuilder.addPoint(envelope, point); });
    };
    /**
     * Add MultiLineString
     * @param envelope geometry envelope
     * @param multiLineString multi line string
     */
    GeometryEnvelopeBuilder.addMultiLineString = function (envelope, multiLineString) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, multiLineString);
        multiLineString.lineStrings.forEach(function (lineString) { return GeometryEnvelopeBuilder.addLineString(envelope, lineString); });
    };
    /**
     * Add Polygon
     * @param envelope geometry envelope
     * @param polygon polygon
     */
    GeometryEnvelopeBuilder.addPolygon = function (envelope, polygon) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, polygon);
        polygon.rings.forEach(function (ring) { return GeometryEnvelopeBuilder.addLineString(envelope, ring); });
    };
    /**
     * Add MultiPolygon
     * @param envelope geometry envelope
     * @param multiPolygon multi polygon
     */
    GeometryEnvelopeBuilder.addMultiPolygon = function (envelope, multiPolygon) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, multiPolygon);
        multiPolygon.polygons.forEach(function (polygon) { return GeometryEnvelopeBuilder.addPolygon(envelope, polygon); });
    };
    /**
     * Add CompoundCurve
     * @param envelope geometry envelope
     * @param compoundCurve compound curve
     */
    GeometryEnvelopeBuilder.addCompoundCurve = function (envelope, compoundCurve) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, compoundCurve);
        compoundCurve.lineStrings.forEach(function (lineString) { return GeometryEnvelopeBuilder.addLineString(envelope, lineString); });
    };
    /**
     * Add CurvePolygon
     * @param envelope geometry envelope
     * @param curvePolygon curve polygon
     */
    GeometryEnvelopeBuilder.addCurvePolygon = function (envelope, curvePolygon) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, curvePolygon);
        curvePolygon.rings.forEach(function (ring) { return GeometryEnvelopeBuilder.buildEnvelopeWithEnvelope(ring, envelope); });
    };
    /**
     * Add PolyhedralSurface
     * @param envelope geometry envelope
     * @param polyhedralSurface polyhedral surface
     */
    GeometryEnvelopeBuilder.addPolyhedralSurface = function (envelope, polyhedralSurface) {
        GeometryEnvelopeBuilder.updateHasZandM(envelope, polyhedralSurface);
        polyhedralSurface.polygons.forEach(function (polygon) { return GeometryEnvelopeBuilder.addPolygon(envelope, polygon); });
    };
    return GeometryEnvelopeBuilder;
}());
exports.GeometryEnvelopeBuilder = GeometryEnvelopeBuilder;
//# sourceMappingURL=GeometryEnvelopeBuilder.js.map