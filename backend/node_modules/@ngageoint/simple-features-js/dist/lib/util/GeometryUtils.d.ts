import { GeometryType, Geometry, Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, CircularString, CompoundCurve, CurvePolygon, PolyhedralSurface, Curve, Line, GeometryEnvelope } from "../internal";
/**
 * Utilities for Geometry objects
 */
export declare class GeometryUtils {
    /**
     * Default epsilon for line tolerance
     */
    static DEFAULT_EPSILON: number;
    /**
     * Get the dimension of the Geometry, 0 for points, 1 for curves, 2 for
     * surfaces. If a collection, the largest dimension is returned.
     * @param geometry geometry object
     * @return dimension (0, 1, or 2)
     */
    static getDimension(geometry: Geometry): number;
    /**
     * Get the Pythagorean theorem distance between two points
     * @param point1 point 1
     * @param point2 point 2
     * @return distance
     */
    static distance(point1: Point, point2: Point): number;
    /**
     * Get the Pythagorean theorem distance between the line end points
     *
     * @param line
     *            line
     * @return distance
     * @since 1.1.1
     */
    static distanceFromLine(line: Line): number;
    /**
     * Get the bearing heading in degrees between two points in degrees
     *
     * @param point1
     *            point 1
     * @param point2
     *            point 2
     * @return bearing angle in degrees between 0 and 360
     * @since 1.1.1
     */
    static bearing(point1: Point, point2: Point): number;
    /**
     * Get the bearing heading in degrees between line end points in degrees
     *
     * @param line
     *            line
     * @return bearing angle in degrees between 0 inclusively and 360
     *         exclusively
     * @since 1.1.1
     */
    static bearingLine(line: Line): number;
    /**
     * Determine if the bearing is in any north direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if north bearing
     * @since 1.1.1
     */
    static isNorthBearing(bearing: number): boolean;
    /**
     * Determine if the bearing is in any east direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if east bearing
     * @since 1.1.1
     */
    static isEastBearing(bearing: number): boolean;
    /**
     * Determine if the bearing is in any south direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if south bearing
     * @since 1.1.1
     */
    static isSouthBearing(bearing: number): boolean;
    /**
     * Determine if the bearing is in any west direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if west bearing
     * @since 1.1.1
     */
    static isWestBearing(bearing: number): boolean;
    /**
     * Convert degrees to radians
     *
     * @param degrees
     *            degrees
     * @return radians
     * @since 1.1.1
     */
    static degreesToRadians(degrees: number): number;
    /**
     * Convert radians to degrees
     *
     * @param radians
     *            radians
     * @return degrees
     * @since 1.1.1
     */
    static radiansToDegrees(radians: number): number;
    /**
     * Get the centroid point of a 2 dimensional representation of the Geometry
     * (balancing point of a 2d cutout of the geometry). Only the x and y
     * coordinate of the resulting point are calculated and populated. The
     * resulting {@link Point#getZ()} and {@link Point#getM()} methods will
     * always return null.
     * @param geometry geometry object
     * @return centroid point
     */
    static getCentroid(geometry: Geometry): Point;
    /**
     * Get the geographic centroid point of a 2 dimensional representation of
     * the degree unit Geometry. Only the x and y coordinate of the resulting
     * point are calculated and populated. The resulting {@link Point#getZ()}
     * and {@link Point#getM()} methods will always return null.
     *
     * @param geometry  geometry object
     * @return centroid point
     */
    static getDegreesCentroid(geometry: Geometry): Point;
    /**
     * Minimize the WGS84 geometry using the shortest x distance between each
     * connected set of points. Resulting x values will be in the range: -540.0
     * &lt;= x &lt;= 540.0
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    static minimizeWGS84(geometry: Geometry): void;
    /**
     * Minimize the Web Mercator geometry using the shortest x distance between
     * each connected set of points. Resulting x values will be in the range:
     * -60112525.028367732 &lt;= x &lt;= 60112525.028367732
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    static minimizeWebMercator(geometry: Geometry): void;
    /**
     * Minimize the geometry using the shortest x distance between each
     * connected set of points. The resulting geometry point x values will be in
     * the range: (3 * min value &lt;= x &lt;= 3 * max value
     *
     * Example: For WGS84 provide a max x of 180.0. Resulting x values will be
     * in the range: -540.0 &lt;= x &lt;= 540.0
     *
     * Example: For web mercator provide a world width of 20037508.342789244.
     * Resulting x values will be in the range: -60112525.028367732 &lt;= x
     * &lt;= 60112525.028367732
     *
     * @param geometry geometry
     * @param maxX max positive x value in the geometry projection
     */
    static minimizeGeometry(geometry: Geometry, maxX: number): void;
    /**
     * Minimize the geometry using the shortest x distance between each
     * connected set of points. The resulting geometry point x values will be in
     * the range: (3 * min value &lt;= x &lt;= 3 * max value
     *
     * Example: For WGS84 provide a max x of
     * {@link GeometryConstants#WGS84_HALF_WORLD_LON_WIDTH}. Resulting x values
     * will be in the range: -540.0 &lt;= x &lt;= 540.0
     *
     * Example: For web mercator provide a world width of
     * {@link GeometryConstants#WEB_MERCATOR_HALF_WORLD_WIDTH}. Resulting x
     * values will be in the range: -60112525.028367732 &lt;= x &lt;=
     * 60112525.028367732
     *
     * @param geometry
     *            geometry
     * @param maxX
     *            max positive x value in the geometry projection
     * @since 1.1.1
     */
    static minimize(geometry: Geometry, maxX: number): void;
    /**
     * Minimize the line string
     *
     * @param lineString
     *            line string
     * @param maxX
     *            max positive x value in the geometry projection
     */
    private static minimizeLineString;
    /**
     * Minimize the multi line string
     * @param multiLineString multi line string
     * @param maxX max positive x value in the geometry projection
     */
    private static minimizeMultiLineString;
    /**
     * Minimize the polygon
     * @param polygon polygon
     * @param maxX max positive x value in the geometry projection
     */
    private static minimizePolygon;
    /**
     * Minimize the multi polygon
     * @param multiPolygon multi polygon
     * @param maxX max positive x value in the geometry projection
     */
    private static minimizeMultiPolygon;
    /**
     * Minimize the compound curve
     * @param compoundCurve compound curve
     * @param maxX max positive x value in the geometry projection
     */
    private static minimizeCompoundCurve;
    /**
     * Minimize the curve polygon
     * @param curvePolygon curve polygon
     * @param maxX max positive x value in the geometry projection
     */
    private static minimizeCurvePolygon;
    /**
     * Minimize the polyhedral surface
     * @param polyhedralSurface polyhedral surface
     * @param maxX max positive x value in the geometry projection
     */
    private static minimizePolyhedralSurface;
    /**
     * Normalize the WGS84 geometry using the shortest x distance between each
     * connected set of points. Resulting x values will be in the range: -180.0
     * &lt;= x &lt;= 180.0
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    static normalizeWGS84(geometry: Geometry): void;
    /**
     * Normalize the Web Mercator geometry using the shortest x distance between
     * each connected set of points. Resulting x values will be in the range:
     * -20037508.342789244 &lt;= x &lt;= 20037508.342789244
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    static normalizeWebMercator(geometry: Geometry): void;
    /**
     * Normalize the geometry so all points outside of the min and max value
     * range are adjusted to fall within the range.
     *
     * Example: For WGS84 provide a max x of 180.0. Resulting x values will be
     * in the range: -180.0 &lt;= x &lt;= 180.0.
     *
     * Example: For web mercator provide a world width of 20037508.342789244.
     * Resulting x values will be in the range: -20037508.342789244 &lt;= x
     * &lt;= 20037508.342789244.
     *
     * @param geometry geometry
     * @param maxX max positive x value in the geometry projection
     */
    static normalizeGeometry(geometry: Geometry, maxX: number): void;
    /**
     * Normalize the geometry so all points outside of the min and max value
     * range are adjusted to fall within the range.
     *
     * Example: For WGS84 provide a max x of
     * {@link GeometryConstants#WGS84_HALF_WORLD_LON_WIDTH}. Resulting x values
     * will be in the range: -180.0 &lt;= x &lt;= 180.0
     *
     * Example: For web mercator provide a world width of
     * {@link GeometryConstants#WEB_MERCATOR_HALF_WORLD_WIDTH}. Resulting x
     * values will be in the range: -20037508.342789244 &lt;= x &lt;=
     * 20037508.342789244
     *
     * @param geometry
     *            geometry
     * @param maxX
     *            max positive x value in the geometry projection
     * @since 1.1.1
     */
    static normalize(geometry: Geometry, maxX: number): void;
    /**
     * Normalize the point
     *
     * @param point
     *            point
     * @param maxX
     *            max positive x value in the geometry projection
     */
    private static normalizePoint;
    /**
     * Normalize the multi point
     * @param multiPoint multi point
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizeMultiPoint;
    /**
     * Normalize the line string
     * @param lineString line string
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizeLineString;
    /**
     * Normalize the multi line string
     * @param multiLineString  multi line string
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizeMultiLineString;
    /**
     * Normalize the polygon
     * @param polygon polygon
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizePolygon;
    /**
     * Normalize the multi polygon
     * @param multiPolygon  multi polygon
     * @param maxX  max positive x value in the geometry projection
     */
    private static normalizeMultiPolygon;
    /**
     * Normalize the compound curve
     * @param compoundCurve compound curve
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizeCompoundCurve;
    /**
     * Normalize the curve polygon
     * @param curvePolygon curve polygon
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizeCurvePolygon;
    /**
     * Normalize the polyhedral surface
     * @param polyhedralSurface polyhedral surface
     * @param maxX max positive x value in the geometry projection
     */
    private static normalizePolyhedralSurface;
    /**
     * Normalize the x value
     *
     * @param x
     *            x value
     * @param maxX
     *            max positive x value in the geometry projection
     */
    private static normalizeX;
    /**
     * Simplify the ordered points (representing a line, polygon, etc) using the
     * Douglas Peucker algorithm to create a similar curve with fewer points.
     * Points should be in a meters unit type projection. The tolerance is the
     * minimum tolerated distance between consecutive points.
     *
     * @param points geometry points
     * @param tolerance minimum tolerance in meters for consecutive points
     * @return simplified points
     * @since 1.0.4
     */
    static simplifyPoints(points: Array<Point>, tolerance: number): Array<Point>;
    /**
     * Simplify the ordered points (representing a line, polygon, etc) using the
     * Douglas Peucker algorithm to create a similar curve with fewer points.
     * Points should be in a meters unit type projection. The tolerance is the
     * minimum tolerated distance between consecutive points.
     *
     * @param points geometry points
     * @param tolerance minimum tolerance in meters for consecutive points
     * @param startIndex start index
     * @param endIndex end index
     * @return simplified points
     */
    private static _simplifyPoints;
    /**
     * Calculate the perpendicular distance between the point and the line
     * represented by the start and end points. Points should be in a meters
     * unit type projection.
     *
     * @param point point
     * @param lineStart point representing the line start
     * @param lineEnd point representing the line end
     * @return distance in meters
     */
    static perpendicularDistance(point: Point, lineStart: Point, lineEnd: Point): number;
    /**
     * Check if the point is in the polygon
     * @param point point
     * @param polygon polygon
     * @return true if in the polygon
     */
    static pointInPolygon(point: Point, polygon: Polygon): boolean;
    /**
     * Check if the point is in the polygon
     *
     * @param point point
     * @param polygon polygon
     * @param epsilon epsilon line tolerance
     * @return true if in the polygon
     */
    static pointInPolygonWithEpsilon(point: Point, polygon: Polygon, epsilon: number): boolean;
    /**
     * Check if the point is in the polygon ring
     *
     * @param point point
     * @param ring polygon ring
     * @return true if in the polygon
     */
    static pointInPolygonRing(point: Point, ring: LineString): boolean;
    /**
     * Check if the point is in the polygon ring
     *
     * @param point point
     * @param ring polygon ring
     * @param epsilon epsilon line tolerance
     * @return true if in the polygon
     */
    static pointInPolygonRingWithEpsilon(point: Point, ring: LineString, epsilon: number): boolean;
    /**
     * Check if the point is in the polygon points
     * @param point point
     * @param points polygon points
     * @return true if in the polygon
     */
    static pointInPolygonRingPoints(point: Point, points: Array<Point>): boolean;
    /**
     * Check if the point is in the polygon points
     * @param point point
     * @param points polygon points
     * @param epsilon epsilon line tolerance
     * @return true if in the polygon
     */
    static pointInPolygonRingPointsWithEpsilon(point: Point, points: Array<Point>, epsilon: number): boolean;
    /**
     * Check if the point is on the polygon edge
     * @param point point
     * @param polygon polygon
     * @return true if on the polygon edge
     */
    static pointOnPolygonEdge(point: Point, polygon: Polygon): boolean;
    /**
     * Check if the point is on the polygon edge
     *
     * @param point point
     * @param polygon polygon
     * @param epsilon epsilon line tolerance
     * @return true if on the polygon edge
     */
    static pointOnPolygonEdgeWithEpsilon(point: Point, polygon: Polygon, epsilon: number): boolean;
    /**
     * Check if the point is on the polygon ring edge
     * @param point point
     * @param ring polygon ring
     * @return true if on the polygon edge
     */
    static pointOnPolygonEdgeRing(point: Point, ring: LineString): boolean;
    /**
     * Check if the point is on the polygon ring edge
     *
     * @param point point
     * @param ring polygon ring
     * @param epsilon epsilon line tolerance
     * @return true if on the polygon edge
     */
    static pointOnPolygonEdgeRingWithEpsilon(point: Point, ring: LineString, epsilon: number): boolean;
    /**
     * Check if the point is on the polygon ring edge points
     * @param point point
     * @param points polygon points
     * @return true if on the polygon edge
     */
    static pointOnPolygonEdgePoints(point: Point, points: Array<Point>): boolean;
    /**
     * Check if the point is on the polygon ring edge points
     * @param point point
     * @param points polygon points
     * @param epsilon epsilon line tolerance
     * @return true if on the polygon edge
     */
    static pointOnPolygonEdgePointsWithEpsilon(point: Point, points: Array<Point>, epsilon: number): boolean;
    /**
     * Check if the polygon outer ring is explicitly closed, where the first and
     * last point are the same
     * @param polygon polygon
     * @return true if the first and last points are the same
     */
    static closedPolygon(polygon: Polygon): boolean;
    /**
     * Check if the polygon ring is explicitly closed, where the first and last
     * point are the same
     * @param ring polygon ring
     * @return true if the first and last points are the same
     */
    static closedPolygonRing(ring: LineString): boolean;
    /**
     * Check if the polygon ring points are explicitly closed, where the first
     * and last point are the same
     * @param points polygon ring points
     * @return true if the first and last points are the same
     */
    static closedPolygonPoints(points: Array<Point>): boolean;
    /**
     * Check if the point is on the line
     * @param point point
     * @param line  line
     * @return true if on the line
     */
    static pointOnLine(point: Point, line: LineString): boolean;
    /**
     * Check if the point is on the line
     * @param point point
     * @param line line
     * @param epsilon epsilon line tolerance
     * @return true if on the line
     */
    static pointOnLineWithEpsilon(point: Point, line: LineString, epsilon: number): boolean;
    /**
     * Check if the point is on the line represented by the points
     * @param point point
     * @param points line points
     * @return true if on the line
     */
    static pointOnLinePoints(point: Point, points: Array<Point>): boolean;
    /**
     * Check if the point is on the line represented by the points
     * @param point point
     * @param points line points
     * @param epsilon epsilon line tolerance
     * @return true if on the line
     */
    static pointOnLinePointsWithEpsilon(point: Point, points: Array<Point>, epsilon: number): boolean;
    /**
     * Check if the point is on the path between point 1 and point 2
     * @param point point
     * @param point1 path point 1
     * @param point2 path point 2
     * @return true if on the path
     */
    static pointOnPath(point: Point, point1: Point, point2: Point): boolean;
    /**
     * Check if the point is on the path between point 1 and point 2
     * @param point point
     * @param point1 path point 1
     * @param point2 path point 2
     * @param epsilon epsilon line tolerance
     * @return true if on the path
     */
    static pointOnPathWithEpsilon(point: Point, point1: Point, point2: Point, epsilon: number): boolean;
    /**
     * Check if the point is on the path between the points
     * @param point point
     * @param points path points
     * @param epsilon epsilon line tolerance
     * @param circular true if a path exists between the first and last point (a non explicitly closed polygon)
     * @return true if on the path
     */
    private static pointOnPathPointArray;
    /**
     * Get the point intersection between two lines
     *
     * @param line1
     *            first line
     * @param line2
     *            second line
     * @return intersection point or null if no intersection
     * @since 1.1.1
     */
    static intersectionLine(line1: Line, line2: Line): Point;
    /**
     * Get the point intersection between end points of two lines
     *
     * @param line1Point1
     *            first point of the first line
     * @param line1Point2
     *            second point of the first line
     * @param line2Point1
     *            first point of the second line
     * @param line2Point2
     *            second point of the second line
     * @return intersection point or null if no intersection
     * @since 2.1.0
     */
    static intersection(line1Point1: Point, line1Point2: Point, line2Point1: Point, line2Point2: Point): Point;
    /**
     * Convert a geometry in degrees to a geometry in meters
     *
     * @param geometry
     *            geometry in degrees
     * @return geometry in meters
     * @since 1.1.1
     */
    static degreesToMeters(geometry: Geometry): Geometry;
    /**
     * Convert a point in degrees to a point in meters
     *
     * @param point
     *            point in degrees
     * @return point in meters
     * @since 1.1.1
     */
    static degreesToMetersPoint(point: Point): Point;
    /**
     * Convert a coordinate in degrees to a point in meters
     *
     * @param x
     *            x value in degrees
     * @param y
     *            y value in degrees
     * @return point in meters
     * @since 1.1.1
     */
    static degreesToMetersCoord(x: number, y: number): Point;
    /**
     * Convert a multi point in degrees to a multi point in meters
     *
     * @param multiPoint
     *            multi point in degrees
     * @return multi point in meters
     * @since 1.1.1
     */
    static degreesToMetersMultiPoint(multiPoint: MultiPoint): MultiPoint;
    /**
     * Convert a line string in degrees to a line string in meters
     *
     * @param lineString
     *            line string in degrees
     * @return line string in meters
     * @since 2.2.0
     */
    static degreesToMetersLineString(lineString: LineString): LineString;
    /**
     * Convert a line in degrees to a line in meters
     *
     * @param line
     *            line in degrees
     * @return line in meters
     * @since 1.1.1
     */
    static degreesToMetersLine(line: Line): Line;
    /**
     * Convert a multi line string in degrees to a multi line string in meters
     *
     * @param multiLineString
     *            multi line string in degrees
     * @return multi line string in meters
     * @since 1.1.1
     */
    static degreesToMetersMultiLineString(multiLineString: MultiLineString): MultiLineString;
    /**
     * Convert a polygon in degrees to a polygon in meters
     *
     * @param polygon
     *            polygon in degrees
     * @return polygon in meters
     * @since 1.1.1
     */
    static degreesToMetersPolygon(polygon: Polygon): Polygon;
    /**
     * Convert a multi polygon in degrees to a multi polygon in meters
     *
     * @param multiPolygon
     *            multi polygon in degrees
     * @return multi polygon in meters
     * @since 1.1.1
     */
    static degreesToMetersMultiPolygon(multiPolygon: MultiPolygon): MultiPolygon;
    /**
     * Convert a circular string in degrees to a circular string in meters
     *
     * @param circularString
     *            circular string in degrees
     * @return circular string in meters
     * @since 1.1.1
     */
    static degreesToMetersCircularString(circularString: CircularString): CircularString;
    /**
     * Convert a compound curve in degrees to a compound curve in meters
     *
     * @param compoundCurve
     *            compound curve in degrees
     * @return compound curve in meters
     * @since 1.1.1
     */
    static degreesToMetersCompundCurve(compoundCurve: CompoundCurve): CompoundCurve;
    /**
     * Convert a curve polygon in degrees to a curve polygon in meters
     *
     * @param curvePolygon
     *            curve polygon in degrees
     * @return curve polygon in meters
     * @since 1.1.1
     */
    static degreesToMetersCurvePolygon(curvePolygon: CurvePolygon<Curve>): CurvePolygon<Curve>;
    /**
     * Convert a polyhedral surface in degrees to a polyhedral surface in meters
     *
     * @param polyhedralSurface
     *            polyhedral surface in degrees
     * @return polyhedral surface in meters
     * @since 1.1.1
     */
    static degreesToMetersPolyhedralSurface(polyhedralSurface: PolyhedralSurface): PolyhedralSurface;
    /**
     * Convert a geometry in meters to a geometry in degrees
     *
     * @param geometry
     *            geometry in meters
     * @return geometry in degrees
     * @since 1.1.1
     */
    static metersToDegrees(geometry: Geometry): Geometry;
    /**
     * Convert a point in meters to a point in degrees
     *
     * @param point
     *            point in meters
     * @return point in degrees
     * @since 1.1.1
     */
    static metersToDegreesPoint(point: Point): Point;
    /**
     * Convert a coordinate in meters to a point in degrees
     *
     * @param x
     *            x value in meters
     * @param y
     *            y value in meters
     * @return point in degrees
     * @since 1.1.1
     */
    static metersToDegreesCoord(x: number, y: number): Point;
    /**
     * Convert a multi point in meters to a multi point in degrees
     *
     * @param multiPoint
     *            multi point in meters
     * @return multi point in degrees
     * @since 1.1.1
     */
    static metersToDegreesMultiPoint(multiPoint: MultiPoint): MultiPoint;
    /**
     * Convert a line string in meters to a line string in degrees
     *
     * @param lineString
     *            line string in meters
     * @return line string in degrees
     * @since 1.1.1
     */
    static metersToDegreesLineString(lineString: LineString): LineString;
    /**
     * Convert a line in meters to a line in degrees
     *
     * @param line
     *            line in meters
     * @return line in degrees
     * @since 1.1.1
     */
    static metersToDegreesLine(line: Line): Line;
    /**
     * Convert a multi line string in meters to a multi line string in degrees
     *
     * @param multiLineString
     *            multi line string in meters
     * @return multi line string in degrees
     * @since 1.1.1
     */
    static metersToDegreesMultiLineString(multiLineString: MultiLineString): MultiLineString;
    /**
     * Convert a polygon in meters to a polygon in degrees
     *
     * @param polygon
     *            polygon in meters
     * @return polygon in degrees
     * @since 1.1.1
     */
    static metersToDegreesPolygon(polygon: Polygon): Polygon;
    /**
     * Convert a multi polygon in meters to a multi polygon in degrees
     *
     * @param multiPolygon
     *            multi polygon in meters
     * @return multi polygon in degrees
     * @since 1.1.1
     */
    static metersToDegreesMultiPolygon(multiPolygon: MultiPolygon): MultiPolygon;
    /**
     * Convert a circular string in meters to a circular string in degrees
     *
     * @param circularString
     *            circular string in meters
     * @return circular string in degrees
     * @since 1.1.1
     */
    static metersToDegreesCircularString(circularString: CircularString): CircularString;
    /**
     * Convert a compound curve in meters to a compound curve in degrees
     *
     * @param compoundCurve
     *            compound curve in meters
     * @return compound curve in degrees
     * @since 1.1.1
     */
    static metersToDegreesCompoundCurve(compoundCurve: CompoundCurve): CompoundCurve;
    /**
     * Convert a curve polygon in meters to a curve polygon in degrees
     *
     * @param curvePolygon
     *            curve polygon in meters
     * @return curve polygon in degrees
     * @since 2.2.0
     */
    static metersToDegreesCurvePolygon(curvePolygon: CurvePolygon<Curve>): CurvePolygon<Curve>;
    /**
     * Convert a polyhedral surface in meters to a polyhedral surface in degrees
     *
     * @param polyhedralSurface
     *            polyhedral surface in meters
     * @return polyhedral surface in degrees
     * @since 1.1.1
     */
    static metersToDegreesPolyhedralSurface(polyhedralSurface: PolyhedralSurface): PolyhedralSurface;
    /**
     * Get a WGS84 bounded geometry envelope
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    static wgs84Envelope(): GeometryEnvelope;
    /**
     * Get a WGS84 bounded geometry envelope used for projection transformations
     * (degrees to meters)
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    static wgs84TransformableEnvelope(): GeometryEnvelope;
    /**
     * Get a Web Mercator bounded geometry envelope
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    static webMercatorEnvelope(): GeometryEnvelope;
    /**
     * Get a WGS84 geometry envelope with Web Mercator bounds
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    static wgs84EnvelopeWithWebMercator(): GeometryEnvelope;
    /**
     * Crop the geometry in meters by web mercator world bounds. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param geometry
     *            geometry in meters
     * @return cropped geometry in meters or null
     * @since 1.1.1
     */
    static cropWebMercator(geometry: Geometry): Geometry;
    /**
     * Crop the geometry in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param geometry
     *            geometry in meters
     * @param envelope
     *            envelope in meters
     * @return cropped geometry in meters or null
     * @since 1.1.1
     */
    static crop(geometry: Geometry, envelope: GeometryEnvelope): Geometry;
    /**
     * Crop the point by the envelope bounds.
     *
     * @param point
     *            point
     * @param envelope
     *            envelope
     * @return cropped point or null
     * @since 1.1.1
     */
    static cropPoint(point: Point, envelope: GeometryEnvelope): Point;
    /**
     * Crop the list of consecutive points in meters by the envelope bounds in
     * meters. Cropping removes points outside the envelope and creates new
     * points on the line intersections with the envelope.
     *
     * @param points
     *            consecutive points
     * @param envelope
     *            envelope in meters
     * @return cropped points in meters or null
     * @since 1.1.1
     */
    static cropPoints(points: Point[], envelope: GeometryEnvelope): Point[];
    /**
     * Crop the multi point by the envelope bounds.
     *
     * @param multiPoint
     *            multi point
     * @param envelope
     *            envelope
     * @return cropped multi point or null
     * @since 1.1.1
     */
    static cropMultiPoint(multiPoint: MultiPoint, envelope: GeometryEnvelope): MultiPoint;
    /**
     * Crop the line string in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param lineString
     *            line string in meters
     * @param envelope
     *            envelope in meters
     * @return cropped line string in meters or null
     * @since 1.1.1
     */
    static cropLineString(lineString: LineString, envelope: GeometryEnvelope): LineString;
    /**
     * Crop the line in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param line
     *            line in meters
     * @param envelope
     *            envelope in meters
     * @return cropped line in meters or null
     * @since 1.1.1
     */
    static cropLine(line: Line, envelope: GeometryEnvelope): Line;
    /**
     * Crop the multi line string in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param multiLineString
     *            multi line string in meters
     * @param envelope
     *            envelope in meters
     * @return cropped multi line string in meters or null
     * @since 1.1.1
     */
    static cropMultiLineString(multiLineString: MultiLineString, envelope: GeometryEnvelope): MultiLineString;
    /**
     * Crop the polygon in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param polygon
     *            polygon in meters
     * @param envelope
     *            envelope in meters
     * @return cropped polygon in meters or null
     * @since 1.1.1
     */
    static cropPolygon(polygon: Polygon, envelope: GeometryEnvelope): Polygon;
    /**
     * Crop the multi polygon in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param multiPolygon
     *            multi polygon in meters
     * @param envelope
     *            envelope in meters
     * @return cropped multi polygon in meters or null
     * @since 1.1.1
     */
    static cropMultiPolygon(multiPolygon: MultiPolygon, envelope: GeometryEnvelope): MultiPolygon;
    /**
     * Crop the circular string in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param circularString
     *            circular string in meters
     * @param envelope
     *            envelope in meters
     * @return cropped circular string in meters or null
     * @since 1.1.1
     */
    static cropCircularString(circularString: CircularString, envelope: GeometryEnvelope): CircularString;
    /**
     * Crop the compound curve in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param compoundCurve
     *            compound curve in meters
     * @param envelope
     *            envelope in meters
     * @return cropped compound curve in meters or null
     * @since 1.1.1
     */
    static cropCompoundCurve(compoundCurve: CompoundCurve, envelope: GeometryEnvelope): CompoundCurve;
    /**
     * Crop the curve polygon in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param curvePolygon
     *            curve polygon in meters
     * @param envelope
     *            envelope in meters
     * @return cropped curve polygon in meters or null
     * @since 1.1.1
     */
    static cropCurvePolygon(curvePolygon: CurvePolygon<Curve>, envelope: GeometryEnvelope): CurvePolygon<Curve>;
    /**
     * Crop the polyhedral surface in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param polyhedralSurface
     *            polyhedral surface in meters
     * @param envelope
     *            envelope in meters
     * @return cropped polyhedral surface in meters or null
     * @since 1.1.1
     */
    static cropPolyhedralSurface(polyhedralSurface: PolyhedralSurface, envelope: GeometryEnvelope): PolyhedralSurface;
    /**
     * Determine if the points are equal within the default tolerance of
     * {@link GeometryConstants#DEFAULT_EQUAL_EPSILON}. For exact equality, use
     * {@link Point#equals(Object)}.
     *
     * @param point1
     *            point 1
     * @param point2
     *            point 2
     * @return true if equal
     * @since 1.1.1
     */
    static isEqual(point1: Point, point2: Point): boolean;
    /**
     * Determine if the points are equal within the tolerance. For exact
     * equality, use {@link Point#equals(Object)}.
     *
     * @param point1
     *            point 1
     * @param point2
     *            point 2
     * @param epsilon
     *            epsilon equality tolerance
     * @return true if equal
     * @since 1.1.1
     */
    static isEqualWithEpsilon(point1: Point, point2: Point, epsilon: number): boolean;
    /**
     * Determine if the envelope contains the point within the default tolerance
     * of {@link GeometryConstants#DEFAULT_EQUAL_EPSILON}. For exact equality,
     * use {@link GeometryEnvelope#contains(Point)}.
     *
     * @param envelope
     *            envelope
     * @param point
     *            point
     * @return true if contains
     * @since 1.1.1
     */
    static containsPoint(envelope: GeometryEnvelope, point: Point): boolean;
    /**
     * Determine if the first envelope contains the second within the default
     * tolerance of {@link GeometryConstants#DEFAULT_EQUAL_EPSILON}. For exact
     * equality, use {@link GeometryEnvelope#contains(GeometryEnvelope)}.
     *
     * @param envelope1
     *            envelope 1
     * @param envelope2
     *            envelope 2
     * @return true if contains
     * @since 1.1.1
     */
    static containsGeometryEnvelope(envelope1: GeometryEnvelope, envelope2: GeometryEnvelope): boolean;
    /**
     * Bound all points in the geometry to be within WGS84 limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #degreesToMeters(Geometry)} and
     * {@link #crop(Geometry, GeometryEnvelope)}.
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    static boundWGS84(geometry: Geometry): void;
    /**
     * Bound all points in the geometry to be within WGS84 projection
     * transformable (degrees to meters) limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #degreesToMeters(Geometry)} and
     * {@link #crop(Geometry, GeometryEnvelope)}.
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    static boundWGS84Transformable(geometry: Geometry): void;
    /**
     * Bound all points in the geometry to be within Web Mercator limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #cropWebMercator(Geometry)}.
     *
     * @param geometry
     *            geometry
     * @since 2.2.0
     */
    static boundWebMercator(geometry: Geometry): void;
    /**
     * Bound all points in the WGS84 geometry to be within degree Web Mercator
     * limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #degreesToMeters(Geometry)} and
     * {@link #cropWebMercator(Geometry)}.
     *
     * @param geometry
     *            geometry
     * @since 2.2.0
     */
    static boundWGS84WithWebMercator(geometry: Geometry): void;
    /**
     * Bound all points in the geometry to be within the geometry envelope.
     * Point x and y values are bounded by the min and max envelope values.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #crop(Geometry, GeometryEnvelope)} (requires geometry in meters).
     *
     * @param geometry
     *            geometry
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    static bound(geometry: Geometry, envelope: GeometryEnvelope): void;
    /**
     * Bound the point by the geometry envelope
     *
     * @param point
     *            point
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundPoint;
    /**
     * Bound the multi point by the geometry envelope
     *
     * @param multiPoint
     *            multi point
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundMultiPoint;
    /**
     * Bound the line string by the geometry envelope
     *
     * @param lineString
     *            line string
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundLineString;
    /**
     * Bound the multi line string by the geometry envelope
     *
     * @param multiLineString
     *            multi line string
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundMultiLineString;
    /**
     * Bound the polygon by the geometry envelope
     *
     * @param polygon
     *            polygon
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundPolygon;
    /**
     * Bound the multi polygon by the geometry envelope
     *
     * @param multiPolygon
     *            multi polygon
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundMultiPolygon;
    /**
     * Bound the compound curve by the geometry envelope
     *
     * @param compoundCurve
     *            compound curve
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundCompoundCurve;
    /**
     * Bound the curve polygon by the geometry envelope
     *
     * @param curvePolygon
     *            curve polygon
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundCurvePolygon;
    /**
     * Bound the polyhedral surface by the geometry envelope
     *
     * @param polyhedralSurface
     *            polyhedral surface
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    private static boundPolyhedralSurface;
    /**
     * Get the parent type hierarchy of the provided geometry type starting with
     * the immediate parent. If the argument is GEOMETRY, an empty list is
     * returned, else the final type in the list will be GEOMETRY.
     * @param geometryType geometry type
     * @return list of increasing parent types
     */
    static parentHierarchy(geometryType: GeometryType): Array<GeometryType>;
    /**
     * Get the parent Geometry Type of the provided geometry type
     * @param geometryType geometry type
     * @return parent geometry type or null if argument is GEOMETRY (no parent type)
     */
    static parentType(geometryType: GeometryType): GeometryType;
    /**
     * Get the child type hierarchy of the provided geometry type.
     * @param geometryType geometry type
     * @return child type hierarchy, null if no children
     */
    static childHierarchy(geometryType: GeometryType): Map<GeometryType, Map<GeometryType, any>>;
    /**
     * Get the immediate child Geometry Types of the provided geometry type
     * @param geometryType geometry type
     * @return child geometry types, empty list if no child types
     */
    static childTypes(geometryType: GeometryType): Array<GeometryType>;
}
