"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryPrinter = void 0;
var internal_1 = require("../internal");
/**
 * String representation of a Geometry
 */
var GeometryPrinter = /** @class */ (function () {
    function GeometryPrinter() {
    }
    /**
     * Get Geometry Information as a String
     * @param geometry geometry
     * @return geometry String
     */
    GeometryPrinter.getGeometryString = function (geometry) {
        var message = [];
        var geometryType = geometry.geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.POINT:
                GeometryPrinter.addPointMessage(message, geometry);
                break;
            case internal_1.GeometryType.LINESTRING:
                GeometryPrinter.addLineStringMessage(message, geometry);
                break;
            case internal_1.GeometryType.POLYGON:
                GeometryPrinter.addPolygonMessage(message, geometry);
                break;
            case internal_1.GeometryType.MULTIPOINT:
                GeometryPrinter.addMultiPointMessage(message, geometry);
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                GeometryPrinter.addMultiLineStringMessage(message, geometry);
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                GeometryPrinter.addMultiPolygonMessage(message, geometry);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                GeometryPrinter.addLineStringMessage(message, geometry);
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                GeometryPrinter.addCompoundCurveMessage(message, geometry);
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                GeometryPrinter.addCurvePolygonMessage(message, geometry);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                GeometryPrinter.addPolyhedralSurfaceMessage(message, geometry);
                break;
            case internal_1.GeometryType.TIN:
                GeometryPrinter.addPolyhedralSurfaceMessage(message, geometry);
                break;
            case internal_1.GeometryType.TRIANGLE:
                GeometryPrinter.addPolygonMessage(message, geometry);
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                var geomCollection = geometry;
                message.push("Geometries: " + geomCollection.numGeometries());
                var geometries = geomCollection.geometries;
                for (var i = 0; i < geometries.length; i++) {
                    var subGeometry = geometries[i];
                    message.push("\n\n");
                    message.push("Geometry " + (i + 1));
                    message.push("\n");
                    message.push(internal_1.GeometryType.nameFromType(subGeometry.geometryType));
                    message.push("\n");
                    message.push(GeometryPrinter.getGeometryString(subGeometry));
                }
                break;
            default:
        }
        return message.join('');
    };
    /**
     * Add Point message
     * @param message string message
     * @param point point
     */
    GeometryPrinter.addPointMessage = function (message, point) {
        message.push("Latitude: ");
        message.push(point.y.toString());
        message.push("\nLongitude: ");
        message.push(point.x.toString());
    };
    /**
     * Add MultiPoint message
     * @param message string message
     * @param multiPoint multi point
     */
    GeometryPrinter.addMultiPointMessage = function (message, multiPoint) {
        message.push("Points: " + multiPoint.numPoints());
        var points = multiPoint.points;
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            message.push("\n\n");
            message.push("Point " + (i + 1));
            message.push("\n");
            GeometryPrinter.addPointMessage(message, point);
        }
    };
    /**
     * Add LineString message
     * @param message string message
     * @param lineString line string
     */
    GeometryPrinter.addLineStringMessage = function (message, lineString) {
        var e_1, _a;
        message.push("Points: " + lineString.numPoints());
        try {
            for (var _b = __values(lineString.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                message.push("\n\n");
                GeometryPrinter.addPointMessage(message, point);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Add MultiLineString message
     * @param message string message
     * @param multiLineString  multi line string
     */
    GeometryPrinter.addMultiLineStringMessage = function (message, multiLineString) {
        message.push("LineStrings: " + multiLineString.numLineStrings());
        var lineStrings = multiLineString.lineStrings;
        for (var i = 0; i < lineStrings.length; i++) {
            var lineString = lineStrings[i];
            message.push("\n\n");
            message.push("LineString " + (i + 1));
            message.push("\n");
            GeometryPrinter.addLineStringMessage(message, lineString);
        }
    };
    /**
     * Add Polygon message
     * @param message string message
     * @param polygon polygon
     */
    GeometryPrinter.addPolygonMessage = function (message, polygon) {
        message.push("Rings: " + polygon.numRings());
        var rings = polygon.rings;
        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            message.push("\n\n");
            if (i > 0) {
                message.push("Hole " + i);
                message.push("\n");
            }
            GeometryPrinter.addLineStringMessage(message, ring);
        }
    };
    /**
     * Add MultiPolygon message
     * @param message string message
     * @param multiPolygon multi polygon
     */
    GeometryPrinter.addMultiPolygonMessage = function (message, multiPolygon) {
        message.push("Polygons: "
            + multiPolygon.numPolygons());
        var polygons = multiPolygon.polygons;
        for (var i = 0; i < polygons.length; i++) {
            var polygon = polygons[i];
            message.push("\n\n");
            message.push("Polygon " + (i + 1));
            message.push("\n");
            GeometryPrinter.addPolygonMessage(message, polygon);
        }
    };
    /**
     * Add CompoundCurve message
     * @param message string message
     * @param compoundCurve compound curve
     */
    GeometryPrinter.addCompoundCurveMessage = function (message, compoundCurve) {
        message.push("LineStrings: " + compoundCurve.numLineStrings());
        var lineStrings = compoundCurve.lineStrings;
        for (var i = 0; i < lineStrings.length; i++) {
            var lineString = lineStrings[i];
            message.push("\n\n");
            message.push("LineString " + (i + 1));
            message.push("\n");
            GeometryPrinter.addLineStringMessage(message, lineString);
        }
    };
    /**
     * Add CurvePolygon message
     * @param message string message
     * @param curvePolygon curve polygon
     */
    GeometryPrinter.addCurvePolygonMessage = function (message, curvePolygon) {
        message.push("Rings: " + curvePolygon.numRings());
        var rings = curvePolygon.rings;
        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            message.push("\n\n");
            if (i > 0) {
                message.push("Hole " + i);
                message.push("\n");
            }
            message.push(GeometryPrinter.getGeometryString(ring));
        }
    };
    /**
     * Add PolyhedralSurface message
     * @param message string message
     * @param polyhedralSurface polyhedral surface
     */
    GeometryPrinter.addPolyhedralSurfaceMessage = function (message, polyhedralSurface) {
        message.push("Polygons: " + polyhedralSurface.numPolygons());
        var polygons = polyhedralSurface.polygons;
        for (var i = 0; i < polygons.length; i++) {
            var polygon = polygons[i];
            message.push("\n\n");
            message.push("Polygon " + (i + 1));
            message.push("\n");
            GeometryPrinter.addPolygonMessage(message, polygon);
        }
    };
    return GeometryPrinter;
}());
exports.GeometryPrinter = GeometryPrinter;
//# sourceMappingURL=GeometryPrinter.js.map