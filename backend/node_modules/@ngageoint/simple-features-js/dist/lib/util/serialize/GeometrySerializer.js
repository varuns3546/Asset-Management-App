"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometrySerializer = void 0;
var internal_1 = require("../../internal");
var GeometrySerializer = /** @class */ (function () {
    function GeometrySerializer() {
    }
    /**
     * Serialize the geometry to JSON
     * @param geometry geometry
     * @return serialized JSON
     */
    GeometrySerializer.serialize = function (geometry) {
        return JSON.stringify(geometry);
    };
    GeometrySerializer.fromJSON = function (obj) {
        var geometry;
        var geometryType = obj._geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.POINT:
                var point = new internal_1.Point();
                point.x = obj._x;
                point.y = obj._y;
                point.z = obj._z;
                point.m = obj._m;
                point.hasZ = obj._hasZ;
                point.hasM = obj._hasM;
                geometry = point;
                break;
            case internal_1.GeometryType.LINESTRING:
                var lineString_1 = new internal_1.LineString();
                obj._points.forEach(function (point) {
                    lineString_1.addPoint(GeometrySerializer.fromJSON(point));
                });
                lineString_1.hasZ = obj._hasZ;
                lineString_1.hasM = obj._hasM;
                geometry = lineString_1;
                break;
            case internal_1.GeometryType.POLYGON:
                var polygon_1 = new internal_1.Polygon();
                obj._rings.forEach(function (ring) {
                    polygon_1.addRing(GeometrySerializer.fromJSON(ring));
                });
                polygon_1.hasZ = obj._hasZ;
                polygon_1.hasM = obj._hasM;
                geometry = polygon_1;
                break;
            case internal_1.GeometryType.MULTIPOINT:
                var multiPoint_1 = new internal_1.MultiPoint();
                obj._geometries.forEach(function (point) {
                    multiPoint_1.addPoint(GeometrySerializer.fromJSON(point));
                });
                multiPoint_1.hasZ = obj._hasZ;
                multiPoint_1.hasM = obj._hasM;
                geometry = multiPoint_1;
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                var multiLineString_1 = new internal_1.MultiLineString();
                obj._geometries.forEach(function (lineString) {
                    multiLineString_1.addLineString(GeometrySerializer.fromJSON(lineString));
                });
                multiLineString_1.hasZ = obj._hasZ;
                multiLineString_1.hasM = obj._hasM;
                geometry = multiLineString_1;
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                var multiPolygon_1 = new internal_1.MultiPolygon();
                obj._geometries.forEach(function (polygon) {
                    multiPolygon_1.addPolygon(GeometrySerializer.fromJSON(polygon));
                });
                multiPolygon_1.hasZ = obj._hasZ;
                multiPolygon_1.hasM = obj._hasM;
                geometry = multiPolygon_1;
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
                var geometryCollection_1 = new internal_1.GeometryCollection();
                obj._geometries.forEach(function (geometry) {
                    geometryCollection_1.addGeometry(GeometrySerializer.fromJSON(geometry));
                });
                geometryCollection_1.hasZ = obj._hasZ;
                geometryCollection_1.hasM = obj._hasM;
                geometry = geometryCollection_1;
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                var circularString_1 = new internal_1.CircularString();
                obj._points.forEach(function (point) {
                    circularString_1.addPoint(GeometrySerializer.fromJSON(point));
                });
                circularString_1.hasZ = obj._hasZ;
                circularString_1.hasM = obj._hasM;
                geometry = circularString_1;
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                var compoundCurve_1 = new internal_1.CompoundCurve();
                obj._lineStrings.forEach(function (lineString) {
                    compoundCurve_1.addLineString(GeometrySerializer.fromJSON(lineString));
                });
                compoundCurve_1.hasZ = obj._hasZ;
                compoundCurve_1.hasM = obj._hasM;
                geometry = compoundCurve_1;
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                var curvePolygon_1 = new internal_1.CurvePolygon();
                obj._rings.forEach(function (ring) {
                    curvePolygon_1.addRing(GeometrySerializer.fromJSON(ring));
                });
                curvePolygon_1.hasZ = obj._hasZ;
                curvePolygon_1.hasM = obj._hasM;
                geometry = curvePolygon_1;
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                var polyhedralSurface_1 = new internal_1.PolyhedralSurface();
                obj._polygons.forEach(function (polygon) {
                    polyhedralSurface_1.addPolygon(GeometrySerializer.fromJSON(polygon));
                });
                polyhedralSurface_1.hasZ = obj._hasZ;
                polyhedralSurface_1.hasM = obj._hasM;
                geometry = polyhedralSurface_1;
                break;
            case internal_1.GeometryType.TIN:
                var tin_1 = new internal_1.TIN();
                obj._polygons.forEach(function (polygon) {
                    tin_1.addPolygon(GeometrySerializer.fromJSON(polygon));
                });
                tin_1.hasZ = obj._hasZ;
                tin_1.hasM = obj._hasM;
                geometry = tin_1;
                break;
            case internal_1.GeometryType.TRIANGLE:
                var triangle_1 = new internal_1.Triangle();
                obj._rings.forEach(function (ring) {
                    triangle_1.addRing(GeometrySerializer.fromJSON(ring));
                });
                triangle_1.hasZ = obj._hasZ;
                triangle_1.hasM = obj._hasM;
                geometry = triangle_1;
                break;
            default:
                throw new internal_1.SFException("Geometry Type not supported: " + geometryType);
        }
        return geometry;
    };
    /**
     * Deserialize the json into a geometry
     * @param json serialized json
     * @return geometry
     */
    GeometrySerializer.deserialize = function (json) {
        return GeometrySerializer.fromJSON(JSON.parse(json));
    };
    return GeometrySerializer;
}());
exports.GeometrySerializer = GeometrySerializer;
//# sourceMappingURL=GeometrySerializer.js.map