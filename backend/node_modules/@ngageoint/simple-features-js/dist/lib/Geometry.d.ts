import { GeometryEnvelope, GeometryType, Point } from './internal';
/**
 * The root of the geometry type hierarchy
 */
export declare abstract class Geometry {
    /**
     * Geometry type
     */
    private readonly _geometryType;
    /**
     * Has z coordinates
     */
    private _hasZ;
    /**
     * Has m values
     */
    private _hasM;
    /**
     * Constructor
     * @param geometryType geometry type
     * @param hasZ has z
     * @param hasM has m
     */
    protected constructor(geometryType: GeometryType, hasZ: boolean, hasM: boolean);
    /**
     * Get the geometry type
     * @return geometry type
     */
    get geometryType(): GeometryType;
    /**
     * Does the geometry have z coordinates
     * @return true if has z coordinates
     */
    get hasZ(): boolean;
    /**
     * Set if the geometry has z coordinates
     * @param hasZ true if has z coordinates
     */
    set hasZ(hasZ: boolean);
    /**
     * Does the geometry have z coordinates
     * @return true if has z coordinates
     * @see #hasZ()
     */
    get is3D(): boolean;
    /**
     * Does the geometry have m coordinates
     * @return true if has m coordinates
     */
    get hasM(): boolean;
    /**
     * Set if the geometry has m coordinates
     * @param hasM true if has m coordinates
     */
    set hasM(hasM: boolean);
    /**
     * Update currently false hasZ and hasM values using the provided geometry
     * @param geometry  geometry
     */
    updateZM(geometry: Geometry): void;
    /**
     * Determine if the geometries contain a Z value
     * @param geometries list of geometries
     * @return true if has z
     */
    static hasZ(geometries: Array<Geometry>): boolean;
    /**
     * Determine if the geometries contain a M value
     * @param geometries list of geometries
     * @return true if has m
     */
    static hasM(geometries: Array<Geometry>): boolean;
    /**
     * Does the geometry have m coordinates.
     * @return true if has m coordinates
     * @see #hasM()
     */
    isMeasured(): boolean;
    /**
     * Get the minimum bounding box for this Geometry
     * @return geometry envelope
     */
    getEnvelope(): GeometryEnvelope;
    /**
     * Expand the envelope with the minimum bounding box for this Geometry
     * @param envelope geometry envelope to expand
     */
    expandEnvelope(envelope: GeometryEnvelope): void;
    /**
     * Get the inherent dimension (0, 1, or 2) for this Geometry
     * @return dimension
     */
    getDimension(): number;
    /**
     * Get the mathematical centroid point of a 2 dimensional representation of
     * the Geometry (balancing point of a 2d cutout of the geometry). Only the x
     * and y coordinate of the resulting point are calculated and populated. The
     * resulting {@link Point#getZ()} and {@link Point#getM()} methods will
     * always return null.
     * @return centroid point
     */
    getCentroid(): Point;
    /**
     * Get the geographic centroid point of a 2 dimensional representation of
     * the degree unit Geometry. Only the x and y coordinate of the resulting
     * point are calculated and populated. The resulting {@link Point#getZ()}
     * and {@link Point#getM()} methods will always return null.
     * @return centroid point
     */
    getDegreesCentroid(): Point;
    /**
     * Copy the geometry
     * @return geometry copy
     */
    abstract copy(): Geometry;
    /**
     * Is the Geometry empty
     * @return true if empty
     */
    abstract isEmpty(): boolean;
    /**
     * Determine if this Geometry has no anomalous geometric points, such as
     * self intersection or self tangency
     * @return true if simple
     */
    abstract isSimple(): boolean;
    equals(obj: Geometry): boolean;
}
