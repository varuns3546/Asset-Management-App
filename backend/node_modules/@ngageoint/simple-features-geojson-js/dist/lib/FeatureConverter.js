"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureConverter = void 0;
var simple_features_js_1 = require("@ngageoint/simple-features-js");
/**
 * SimpleFeatures to GeoJSON Geometry Converter
 */
var FeatureConverter = /** @class */ (function () {
    function FeatureConverter() {
    }
    /**
     * Converts a GeoJSON Feature to a SimpleFeatures Geometry
     * @param geoJson
     */
    FeatureConverter.toSimpleFeaturesGeometryFromGeometryObject = function (geoJson) {
        return FeatureConverter.convertFeatureGeometry(geoJson);
    };
    /**
     * Converts a GeoJSON Feature to a SimpleFeatures Geometry
     * @param geoJson
     */
    FeatureConverter.toSimpleFeaturesGeometry = function (geoJson) {
        return FeatureConverter.convertFeatureGeometry(geoJson.geometry);
    };
    /**
     * Converts a FeatureCollection into an array of
     * @param geoJson
     * @return Array<Geometry>
     */
    FeatureConverter.toSimpleFeaturesGeometryArray = function (geoJson) {
        var geometries = [];
        geoJson.features.forEach(function (feature) {
            geometries.push(FeatureConverter.toSimpleFeaturesGeometry(feature));
        });
        return geometries;
    };
    /**
     * Converts a SimpleFeatures Geometry into GeoJSON Geometry
     * @param geometry
     */
    FeatureConverter.toFeatureGeometry = function (geometry) {
        var geoJson = null;
        switch (geometry.geometryType) {
            case simple_features_js_1.GeometryType.POINT:
                geoJson = FeatureConverter.convertPoint(geometry);
                break;
            case simple_features_js_1.GeometryType.LINESTRING:
                geoJson = FeatureConverter.convertLineString(geometry);
                break;
            case simple_features_js_1.GeometryType.POLYGON:
                geoJson = FeatureConverter.convertPolygon(geometry);
                break;
            case simple_features_js_1.GeometryType.MULTIPOINT:
                geoJson = FeatureConverter.convertMultiPoint(geometry);
                break;
            case simple_features_js_1.GeometryType.MULTILINESTRING:
                geoJson = FeatureConverter.convertMultiLineString(geometry);
                break;
            case simple_features_js_1.GeometryType.MULTIPOLYGON:
                geoJson = FeatureConverter.convertMultiPolygon(geometry);
                break;
            case simple_features_js_1.GeometryType.GEOMETRYCOLLECTION:
                geoJson = FeatureConverter.convertGeometryCollection(geometry);
                break;
            default:
                throw new simple_features_js_1.SFException("Unsupported Geometry type " + simple_features_js_1.GeometryType.nameFromType(geometry.geometryType));
                break;
        }
        return geoJson;
    };
    /**
     * Converts a SimpleFeature Geometry into a GeoJSON Feature
     * @param geometry
     */
    FeatureConverter.toFeature = function (geometry) {
        var feature = {
            type: "Feature",
            properties: {},
            geometry: FeatureConverter.toFeatureGeometry(geometry)
        };
        return feature;
    };
    /**
     * Converts a SimpleFeature Geometry into a GeoJSON Feature Collection
     * @param geometry
     */
    FeatureConverter.toFeatureCollection = function (geometry) {
        var featureCollection = {
            type: "FeatureCollection",
            features: [FeatureConverter.toFeature(geometry)]
        };
        return featureCollection;
    };
    /**
     * Converts a GeoJSON geometry into a SimpleFeatures Geometry
     * @param geoJsonGeometry
     * @private
     */
    FeatureConverter.convertFeatureGeometry = function (geoJsonGeometry) {
        var geometry = null;
        switch (geoJsonGeometry.type) {
            case "Point":
                geometry = FeatureConverter.convertFeaturePoint(geoJsonGeometry);
                break;
            case "LineString":
                geometry = FeatureConverter.convertFeatureLineString(geoJsonGeometry);
                break;
            case "Polygon":
                geometry = FeatureConverter.convertFeaturePolygon(geoJsonGeometry);
                break;
            case "MultiPoint":
                geometry = FeatureConverter.convertFeatureMultiPoint(geoJsonGeometry);
                break;
            case "MultiLineString":
                geometry = FeatureConverter.convertFeatureMultiLineString(geoJsonGeometry);
                break;
            case "MultiPolygon":
                geometry = FeatureConverter.convertFeatureMultiPolygon(geoJsonGeometry);
                break;
            case "GeometryCollection":
                geometry = FeatureConverter.convertFeatureGeometryCollection(geoJsonGeometry);
                break;
        }
        return geometry;
    };
    /**
     * Converts a GeoJSON Position into a Simple Features Point
     * @param position
     * @private
     */
    FeatureConverter.convertFeaturePosition = function (position) {
        var point = null;
        if (position != null && position.length != null && position.length >= 2) {
            point = new simple_features_js_1.Point(position[0], position[1]);
            if (position.length >= 3) {
                point.z = position[2];
                point.hasZ = true;
            }
        }
        return point;
    };
    /**
     * Converts a GeoJSON Point feature into a Simple Features Point
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeaturePoint = function (geoJson) {
        var point = null;
        if (geoJson.coordinates != null) {
            point = FeatureConverter.convertFeaturePosition(geoJson.coordinates);
        }
        return point;
    };
    /**
     * Converts a GeoJSON Position into a Simple Features Point
     * @param positions
     * @private
     */
    FeatureConverter.convertFeaturePositionArray = function (positions) {
        var points = [];
        if (positions != null && positions.length != null) {
            positions.forEach(function (position) {
                points.push(FeatureConverter.convertFeaturePosition(position));
            });
        }
        return points;
    };
    /**
     * Converts a GeoJSON Position into a Simple Features Point
     * @param positions
     * @private
     */
    FeatureConverter.convertArrayOfFeaturePositionArray = function (positions) {
        var lineStrings = [];
        if (positions != null && positions.length != null) {
            positions.forEach(function (positions) {
                lineStrings.push(new simple_features_js_1.LineString(FeatureConverter.convertFeaturePositionArray(positions)));
            });
        }
        return lineStrings;
    };
    /**
     * Converts a GeoJSON LineString into a Simple Features LineString
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeatureLineString = function (geoJson) {
        var lineString = null;
        if (geoJson.coordinates != null) {
            lineString = new simple_features_js_1.LineString(FeatureConverter.convertFeaturePositionArray(geoJson.coordinates));
        }
        return lineString;
    };
    /**
     * Converts a GeoJSON Polygon into a Simple Features Polygon
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeaturePolygon = function (geoJson) {
        var polygon = null;
        if (geoJson.coordinates != null) {
            polygon = new simple_features_js_1.Polygon();
            polygon.rings = FeatureConverter.convertArrayOfFeaturePositionArray(geoJson.coordinates);
        }
        return polygon;
    };
    /**
     * Converts a GeoJSON MultiPoint into a Simple Features MultiPoint
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeatureMultiPoint = function (geoJson) {
        var multiPoint = null;
        if (geoJson.coordinates != null) {
            multiPoint = new simple_features_js_1.MultiPoint();
            multiPoint.points = FeatureConverter.convertFeaturePositionArray(geoJson.coordinates);
        }
        return multiPoint;
    };
    /**
     * Converts a GeoJSON MultiLineString into a Simple Features MultiLineString
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeatureMultiLineString = function (geoJson) {
        var multiLineString = null;
        if (geoJson.coordinates != null) {
            multiLineString = new simple_features_js_1.MultiLineString();
            multiLineString.lineStrings = FeatureConverter.convertArrayOfFeaturePositionArray(geoJson.coordinates);
        }
        return multiLineString;
    };
    /**
     * Converts a GeoJSON MultiPolygon into a Simple Features MultiPolygon
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeatureMultiPolygon = function (geoJson) {
        var multiPolygon = null;
        if (geoJson.coordinates != null) {
            multiPolygon = new simple_features_js_1.MultiPolygon();
            geoJson.coordinates.forEach(function (polygonCoordinates) {
                multiPolygon.addPolygon(new simple_features_js_1.Polygon(FeatureConverter.convertArrayOfFeaturePositionArray(polygonCoordinates)));
            });
        }
        return multiPolygon;
    };
    /**
     * Converts a GeoJSON GeometryCollection into a Simple Features GeometryCollection
     * @param geoJson
     * @private
     */
    FeatureConverter.convertFeatureGeometryCollection = function (geoJson) {
        var geometryCollection = null;
        if (geoJson.geometries != null) {
            geometryCollection = new simple_features_js_1.GeometryCollection();
            geoJson.geometries.forEach(function (geometry) {
                geometryCollection.addGeometry(FeatureConverter.convertFeatureGeometry(geometry));
            });
        }
        return geometryCollection;
    };
    /**
     * Converts a Point into a position
     * @param geometry
     */
    FeatureConverter.convertPosition = function (geometry) {
        var coordinate = [];
        if (geometry.x != null && geometry.y != null) {
            coordinate.push(geometry.x);
            coordinate.push(geometry.y);
            if (geometry.hasZ) {
                coordinate.push(geometry.z);
            }
        }
        return coordinate;
    };
    /**
     * Convert a Point
     * @return point
     */
    FeatureConverter.convertPoint = function (geometry) {
        var point = {
            type: "Point",
            coordinates: FeatureConverter.convertPosition(geometry)
        };
        return point;
    };
    /**
     * Converts a line string into an array of positions
     * @param geometry
     */
    FeatureConverter.convertPositionArray = function (geometry) {
        var positions = [];
        geometry.points.forEach(function (point) {
            positions.push(FeatureConverter.convertPosition(point));
        });
        return positions;
    };
    /**
     * Convert a Line String
     * @return line string
     */
    FeatureConverter.convertLineString = function (geometry) {
        var lineString = {
            type: "LineString",
            coordinates: FeatureConverter.convertPositionArray(geometry)
        };
        return lineString;
    };
    /**
     * Converts an array of line strings into an array of array of positions
     * @param lineStrings
     */
    FeatureConverter.convertPositionRings = function (lineStrings) {
        var positionRings = [];
        lineStrings.forEach(function (lineString) {
            positionRings.push(FeatureConverter.convertPositionArray(lineString));
        });
        return positionRings;
    };
    /**
     * Convert a Polygon
     * @return polygon
     */
    FeatureConverter.convertPolygon = function (geometry) {
        var polygon = {
            type: "Polygon",
            coordinates: FeatureConverter.convertPositionRings(geometry.rings)
        };
        return polygon;
    };
    /**
     * Convert a Multi Point
     * @return multi point
     */
    FeatureConverter.convertMultiPoint = function (geometry) {
        var multiPoint = {
            type: "MultiPoint",
            coordinates: []
        };
        geometry.points.forEach(function (point) {
            multiPoint.coordinates.push(FeatureConverter.convertPosition(point));
        });
        return multiPoint;
    };
    /**
     * Convert a Multi Line String
     * @return multi line string
     */
    FeatureConverter.convertMultiLineString = function (geometry) {
        var multiLineString = {
            type: "MultiLineString",
            coordinates: []
        };
        geometry.lineStrings.forEach(function (lineString) {
            multiLineString.coordinates.push(FeatureConverter.convertPositionArray(lineString));
        });
        return multiLineString;
    };
    /**
     * Convert a Multi Polygon
     * @return multi polygon
     */
    FeatureConverter.convertMultiPolygon = function (geometry) {
        var multiPolygon = {
            type: "MultiPolygon",
            coordinates: []
        };
        geometry.polygons.forEach(function (polygon) {
            multiPolygon.coordinates.push(FeatureConverter.convertPositionRings(polygon.rings));
        });
        return multiPolygon;
    };
    /**
     * Read a Geometry Collection
     * @return geometry collection
     */
    FeatureConverter.convertGeometryCollection = function (geometry) {
        var multiLineString = {
            type: "GeometryCollection",
            geometries: []
        };
        geometry.geometries.forEach(function (geometry) {
            multiLineString.geometries.push(FeatureConverter.toFeatureGeometry(geometry));
        });
        return multiLineString;
    };
    return FeatureConverter;
}());
exports.FeatureConverter = FeatureConverter;
//# sourceMappingURL=FeatureConverter.js.map