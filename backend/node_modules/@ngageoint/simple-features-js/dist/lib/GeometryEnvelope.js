"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryEnvelope = void 0;
var internal_1 = require("./internal");
/**
 * Geometry envelope
 */
var GeometryEnvelope = /** @class */ (function () {
    /**
     * Constructor
     */
    function GeometryEnvelope() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        /**
         * True if has z coordinates
         */
        this._hasZ = false;
        /**
         * True if has M measurements
         */
        this._hasM = false;
        if (args.length === 1 && args[0] instanceof GeometryEnvelope) {
            this.minX = args[0].minX;
            this.maxX = args[0].maxX;
            this.minY = args[0].minY;
            this.maxY = args[0].maxY;
            this.hasZ = args[0].hasZ;
            this.minZ = args[0].minZ;
            this.maxZ = args[0].maxZ;
            this.hasM = args[0].hasM;
            this.minM = args[0].minM;
            this.maxM = args[0].maxM;
        }
        else if (args.length === 2) {
            this.hasZ = args[0];
            this.hasM = args[1];
        }
        else if (args.length === 4) {
            this.minX = args[0];
            this.minY = args[1];
            this.maxX = args[2];
            this.maxY = args[3];
        }
        else if (args.length === 6) {
            this.minX = args[0];
            this.minY = args[1];
            this.minZ = args[2];
            this.maxX = args[3];
            this.maxY = args[4];
            this.maxZ = args[5];
        }
        else if (args.length === 8) {
            this.minX = args[0];
            this.minY = args[1];
            this.minZ = args[2];
            this.minM = args[3];
            this.maxX = args[4];
            this.maxY = args[5];
            this.maxZ = args[6];
            this.maxM = args[7];
        }
    }
    /**
     * True if has Z coordinates
     *
     * @return has z
     * @see #hasZ()
     */
    GeometryEnvelope.prototype.is3D = function () {
        return this.hasZ;
    };
    /**
     * True if has M measurements
     * @return has m
     * @see #hasM()
     */
    GeometryEnvelope.prototype.isMeasured = function () {
        return this.hasM;
    };
    Object.defineProperty(GeometryEnvelope.prototype, "minX", {
        /**
         * Get min x
         * @return min x
         */
        get: function () {
            return this._minX;
        },
        /**
         * Set min x
         * @param minX min x
         */
        set: function (minX) {
            this._minX = minX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "maxX", {
        /**
         * Get max x
         * @return max x
         */
        get: function () {
            return this._maxX;
        },
        /**
         * Set max x
         * @param maxX max x
         */
        set: function (maxX) {
            this._maxX = maxX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "minY", {
        /**
         * Get min y
         * @return min y
         */
        get: function () {
            return this._minY;
        },
        /**
         * Set min y
         * @param minY min y
         */
        set: function (minY) {
            this._minY = minY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "maxY", {
        /**
         * Get max y
         * @return max y
         */
        get: function () {
            return this._maxY;
        },
        /**
         * Set max y
         * @param maxY max y
         */
        set: function (maxY) {
            this._maxY = maxY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "hasZ", {
        /**
         * True if has Z coordinates
         * @return has z
         */
        get: function () {
            return this._hasZ;
        },
        /**
         * Set has z coordinates
         * @param hasZ has z
         */
        set: function (hasZ) {
            this._hasZ = hasZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "minZ", {
        /**
         * Get min z
         * @return min z
         */
        get: function () {
            return this._minZ;
        },
        /**
         * Set min z
         * @param minZ min z
         */
        set: function (minZ) {
            this._minZ = minZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "maxZ", {
        /**
         * Get max z
         * @return max z
         */
        get: function () {
            return this._maxZ;
        },
        /**
         * Set max z
         * @param maxZ max z
         */
        set: function (maxZ) {
            this._maxZ = maxZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "hasM", {
        /**
         * Has m coordinates
         * @return true if has m coordinates
         */
        get: function () {
            return this._hasM;
        },
        /**
         * Set has m coordinates
         * @param hasM has m
         */
        set: function (hasM) {
            this._hasM = hasM;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "minM", {
        /**
         * Get min m
         * @return min m
         */
        get: function () {
            return this._minM;
        },
        /**
         * Set min m
         * @param minM min m
         */
        set: function (minM) {
            this._minM = minM;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "maxM", {
        /**
         * Get max m
         * @return max m
         */
        get: function () {
            return this._maxM;
        },
        /**
         * Set max m
         * @param maxM max m
         */
        set: function (maxM) {
            this._maxM = maxM;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "xRange", {
        /**
         * Get the x range
         * @return x range
         */
        get: function () {
            return this._maxX - this._minX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "yRange", {
        /**
         * Get the y range
         * @return y range
         */
        get: function () {
            return this._maxY - this._minY;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "zRange", {
        /**
         * Get the z range
         * @return z range
         */
        get: function () {
            var range = null;
            if (this._minZ != null && this._maxZ != null) {
                range = this._maxZ - this._minZ;
            }
            return range;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GeometryEnvelope.prototype, "mRange", {
        /**
         * Get the m range
         * @return m range
         */
        get: function () {
            var range = null;
            if (this._minM != null && this._maxM != null) {
                range = this._maxM - this._minM;
            }
            return range;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Determine if the envelope is of a single point
     * @return true if a single point bounds
     * @since 2.0.5
     */
    GeometryEnvelope.prototype.isPoint = function () {
        return this._minX === this._maxX && this._minY === this._maxY;
    };
    /**
     * Get the top left point
     *
     * @return top left point
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getTopLeft = function () {
        return new internal_1.Point(this.minX, this.maxY);
    };
    /**
     * Get the bottom left point
     *
     * @return bottom left point
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getBottomLeft = function () {
        return new internal_1.Point(this.minX, this.minY);
    };
    /**
     * Get the bottom right point
     *
     * @return bottom right point
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getBottomRight = function () {
        return new internal_1.Point(this.maxX, this.minY);
    };
    /**
     * Get the top right point
     *
     * @return top right point
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getTopRight = function () {
        return new internal_1.Point(this.maxX, this.maxY);
    };
    /**
     * Get the left line
     *
     * @return left line
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getLeft = function () {
        return new internal_1.Line(this.getTopLeft(), this.getBottomLeft());
    };
    /**
     * Get the bottom line
     *
     * @return bottom line
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getBottom = function () {
        return new internal_1.Line(this.getBottomLeft(), this.getBottomRight());
    };
    /**
     * Get the right line
     *
     * @return right line
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getRight = function () {
        return new internal_1.Line(this.getBottomRight(), this.getTopRight());
    };
    /**
     * Get the top line
     *
     * @return top line
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.getTop = function () {
        return new internal_1.Line(this.getTopRight(), this.getTopLeft());
    };
    /**
     * Get the envelope mid x
     *
     * @return mid x
     * @since 1.0.3
     */
    GeometryEnvelope.prototype.getMidX = function () {
        return (this.minX + this.maxX) / 2.0;
    };
    /**
     * Get the envelope mid y
     *
     * @return mid y
     * @since 1.0.3
     */
    GeometryEnvelope.prototype.getMidY = function () {
        return (this.minY + this.maxY) / 2.0;
    };
    Object.defineProperty(GeometryEnvelope.prototype, "centroid", {
        /**
         * Get the envelope centroid point
         * @return centroid point
         */
        get: function () {
            return new internal_1.Point((this._minX + this._maxX) / 2.0, (this._minY + this._maxY) / 2.0);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Determine if the envelope is empty
     *
     * @return true if empty
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.isEmpty = function () {
        return this.xRange <= 0.0 || this.yRange <= 0.0;
    };
    /**
     * Determine if intersects with the provided envelope
     * @param envelope geometry envelope
     * @param allowEmpty allow empty ranges when determining intersection
     * @return true if intersects
     */
    GeometryEnvelope.prototype.intersects = function (envelope, allowEmpty) {
        return this.overlap(envelope, allowEmpty) != null;
    };
    /**
     * Get the overlapping geometry envelope with the provided envelope
     * @param envelope geometry envelope
     * @param allowEmpty allow empty ranges when determining intersection
     * @return geometry envelope
     */
    GeometryEnvelope.prototype.overlap = function (envelope, allowEmpty) {
        if (allowEmpty === void 0) { allowEmpty = false; }
        var minX = Math.max(this.minX, envelope.minX);
        var maxX = Math.min(this.maxX, envelope.maxX);
        var minY = Math.max(this.minY, envelope.minY);
        var maxY = Math.min(this.maxY, envelope.maxY);
        var overlap = null;
        if ((minX < maxX && minY < maxY) || (allowEmpty && minX <= maxX && minY <= maxY)) {
            overlap = new GeometryEnvelope(minX, minY, maxX, maxY);
        }
        return overlap;
    };
    /**
     * Get the union geometry envelope combined with the provided envelope
     * @param envelope geometry envelope
     * @return geometry envelope
     */
    GeometryEnvelope.prototype.union = function (envelope) {
        var minX = Math.min(this.minX, envelope.minX);
        var maxX = Math.max(this.maxX, envelope.maxX);
        var minY = Math.min(this.minY, envelope.minY);
        var maxY = Math.max(this.maxY, envelope.maxY);
        var union = null;
        if (minX < maxX && minY < maxY) {
            union = new GeometryEnvelope(minX, minY, maxX, maxY);
        }
        return union;
    };
    /**
     * Determine if contains the point
     *
     * @param point
     *            point
     * @return true if contains
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.containsPoint = function (point) {
        return this.containsPointWithEpsilon(point, 0.0);
    };
    /**
     * Determine if contains the point
     *
     * @param point
     *            point
     * @param epsilon
     *            epsilon equality tolerance
     * @return true if contains
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.containsPointWithEpsilon = function (point, epsilon) {
        return this.containsCoordsWithEpsilon(point.x, point.y, epsilon);
    };
    /**
     * Determine if contains the coordinate
     *
     * @param x
     *            x value
     * @param y
     *            y value
     * @return true if contains
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.containsCoords = function (x, y) {
        return this.containsCoordsWithEpsilon(x, y, 0.0);
    };
    /**
     * Determine if contains the coordinate
     *
     * @param x
     *            x value
     * @param y
     *            y value
     * @param epsilon
     *            epsilon equality tolerance
     * @return true if contains
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.containsCoordsWithEpsilon = function (x, y, epsilon) {
        return x >= this.minX - epsilon && x <= this.maxX + epsilon
            && y >= this.minY - epsilon && y <= this.maxY + epsilon;
    };
    /**
     * Determine if inclusively contains the provided envelope
     * @param envelope geometry envelope
     * @return true if contains
     */
    GeometryEnvelope.prototype.contains = function (envelope) {
        return this.containsWithEpsilon(envelope, 0.0);
    };
    /**
     * Determine if inclusively contains the provided envelope
     *
     * @param envelope
     *            geometry envelope
     * @param epsilon
     *            epsilon equality tolerance
     * @return true if contains
     * @since 1.1.1
     */
    GeometryEnvelope.prototype.containsWithEpsilon = function (envelope, epsilon) {
        return this.minX - epsilon <= envelope.minX
            && this.maxX + epsilon >= envelope.maxX
            && this.minY - epsilon <= envelope.minY
            && this.maxY + epsilon >= envelope.maxY;
    };
    /**
     * Build a geometry representation of the geometry envelope
     * @return geometry, polygon or point
     */
    GeometryEnvelope.prototype.buildGeometry = function () {
        var geometry;
        if (this.isPoint()) {
            geometry = new internal_1.Point(this.minX, this.minY);
        }
        else {
            var polygon = new internal_1.Polygon();
            var ring = new internal_1.LineString();
            ring.addPoint(new internal_1.Point(this.minX, this.minY));
            ring.addPoint(new internal_1.Point(this.maxX, this.minY));
            ring.addPoint(new internal_1.Point(this.maxX, this.maxY));
            ring.addPoint(new internal_1.Point(this.minX, this.maxY));
            polygon.addRing(ring);
            geometry = polygon;
        }
        return geometry;
    };
    /**
     * Copy the geometry envelope
     * @return geometry envelope copy
     */
    GeometryEnvelope.prototype.copy = function () {
        return new GeometryEnvelope(this);
    };
    /**
     * {@inheritDoc}
     */
    GeometryEnvelope.prototype.equals = function (obj) {
        return !(!(obj instanceof GeometryEnvelope)
            || this.minX !== obj.minX
            || this.maxX !== obj.maxX
            || this.minY !== obj.minY
            || this.maxY !== obj.maxY
            || this.minZ !== obj.minZ
            || this.maxZ !== obj.maxZ
            || this.minM !== obj.minM
            || this.maxM !== obj.maxM);
    };
    return GeometryEnvelope;
}());
exports.GeometryEnvelope = GeometryEnvelope;
//# sourceMappingURL=GeometryEnvelope.js.map