"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SweepLine = void 0;
var js_cols_1 = require("js_cols");
var internal_1 = require("../../internal");
/**
 * Segment comparator for adding segments to the sweep line in above-below
 * order
 */
var SegmentComparator = /** @class */ (function () {
    function SegmentComparator() {
    }
    Object.defineProperty(SegmentComparator.prototype, "x", {
        /**
         * Set the current sweep x value
         * @param x x value
         */
        set: function (x) {
            this._x = x;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * {@inheritDoc}
     */
    SegmentComparator.prototype.compare = function (segment1, segment2) {
        var y1 = SweepLine.yValueAtX(segment1, this._x);
        var y2 = SweepLine.yValueAtX(segment2, this._x);
        var compare;
        if (y1 < y2) {
            compare = -1;
        }
        else if (y2 < y1) {
            compare = 1;
        }
        else if (segment1.ring < segment2.ring) {
            compare = -1;
        }
        else if (segment2.ring < segment1.ring) {
            compare = 1;
        }
        else if (segment1.edge < segment2.edge) {
            compare = -1;
        }
        else if (segment2.edge < segment1.edge) {
            compare = 1;
        }
        else {
            compare = 0;
        }
        return compare;
    };
    return SegmentComparator;
}());
/**
 * Sweep Line algorithm
 */
var SweepLine = /** @class */ (function () {
    /**
     * Constructor
     * @param rings polygon rings
     */
    function SweepLine(rings) {
        /**
         * Comparator for ordering segments in above-below order
         */
        this._comparator = new SegmentComparator();
        /**
         * Mapping between ring, edges, and segments
         */
        this._segments = new Map();
        this._rings = rings;
        this._tree = new js_cols_1.RedBlackSet(this._comparator.compare.bind(this._comparator));
    }
    /**
     * Add the event to the sweep line
     * @param event event
     * @return added segment
     */
    SweepLine.prototype.add = function (event) {
        var segment = this.createSegment(event);
        // Add to the tree
        this._comparator.x = event.point.x;
        this._tree.insert(segment);
        // Update the above and below pointers
        var next = this._tree.successor(segment);
        var previous = this._tree.predecessor(segment);
        if (next != null) {
            segment.above = next;
            next.below = segment;
        }
        if (previous != null) {
            segment.below = previous;
            previous.above = segment;
        }
        // Add to the segments map
        var edgeMap = this._segments.get(segment.ring);
        if (edgeMap == null) {
            edgeMap = new Map();
            this._segments.set(segment.ring, edgeMap);
        }
        edgeMap.set(segment.edge, segment);
        return segment;
    };
    /**
     * Create a segment from the event
     * @param event event
     * @return segment
     */
    SweepLine.prototype.createSegment = function (event) {
        var edgeNumber = event.edge;
        var ringNumber = event.ring;
        var ring = this._rings[ringNumber];
        var points = ring.points;
        var point1 = points[edgeNumber];
        var point2 = points[(edgeNumber + 1) % points.length];
        var left;
        var right;
        if (SweepLine.xyOrder(point1, point2) < 0) {
            left = point1;
            right = point2;
        }
        else {
            right = point1;
            left = point2;
        }
        return new internal_1.Segment(edgeNumber, ringNumber, left, right);
    };
    /**
     * Find the existing event segment
     *
     * @param event
     *            event
     * @return segment
     */
    SweepLine.prototype.find = function (event) {
        return this._segments.get(event.ring).get(event.edge);
    };
    /**
     * Determine if the two segments intersect
     *
     * @param segment1
     *            segment 1
     * @param segment2
     *            segment 2
     * @return true if intersection, false if not
     */
    SweepLine.prototype.intersect = function (segment1, segment2) {
        var intersect = false;
        if (segment1 != null && segment2 != null) {
            var ring1 = segment1.ring;
            var ring2 = segment2.ring;
            var consecutive = ring1 === ring2;
            if (consecutive) {
                var edge1 = segment1.edge;
                var edge2 = segment2.edge;
                var ringPoints = this._rings[ring1].numPoints();
                consecutive = (edge1 + 1) % ringPoints === edge2 || edge1 === (edge2 + 1) % ringPoints;
            }
            if (!consecutive) {
                var left = SweepLine.isLeft(segment1, segment2.leftPoint);
                var right = SweepLine.isLeft(segment1, segment2.rightPoint);
                if (left * right <= 0) {
                    left = SweepLine.isLeft(segment2, segment1.leftPoint);
                    right = SweepLine.isLeft(segment2, segment1.rightPoint);
                    if (left * right <= 0) {
                        intersect = true;
                    }
                }
            }
        }
        return intersect;
    };
    /**
     * Remove the segment from the sweep line
     * @param segment segment
     */
    SweepLine.prototype.remove = function (segment) {
        var removed = this._tree.remove(segment);
        if (!removed) {
            this._comparator.x = segment.leftPoint.x;
            removed = this._tree.remove(segment);
        }
        if (removed) {
            var above = segment.above;
            var below = segment.below;
            if (above != null) {
                above.below = below;
            }
            if (below != null) {
                below.above = above;
            }
            this._segments.get(segment.ring).delete(segment.edge);
        }
    };
    /**
     * Get the segment y value at the x location by calculating the line slope
     *
     * @param segment segment
     * @param x current point x value
     * @return segment y value
     */
    SweepLine.yValueAtX = function (segment, x) {
        var left = segment.leftPoint;
        var right = segment.rightPoint;
        var m = (right.y - left.y) / (right.x - left.x);
        var b = left.y - (m * left.x);
        return (m * x) + b;
    };
    /**
     * XY order of two points
     * @param point1 point 1
     * @param point2 point 2
     * @return +1 if p1 &gt; p2, -1 if p1 &lt; p2, 0 if equal
     */
    SweepLine.xyOrder = function (point1, point2) {
        var value = 0;
        if (point1.x > point2.x) {
            value = 1;
        }
        else if (point1.x < point2.x) {
            value = -1;
        }
        else if (point1.y > point2.y) {
            value = 1;
        }
        else if (point1.y < point2.y) {
            value = -1;
        }
        return value;
    };
    /**
     * Check where the point is (left, on, right) relative to the line segment
     *
     * @param segment segment
     * @param point point
     * @return > 0 if left, 0 if on, < 0 if right
     */
    SweepLine.isLeft = function (segment, point) {
        return this.isLeftPoints(segment.leftPoint, segment.rightPoint, point);
    };
    /**
     * Check where point 2 is (left, on, right) relative to the line from point
     * 0 to point 1
     * @param point0 point 0
     * @param point1 point 1
     * @param point2 point 2
     * @return > 0 if left, 0 if on, < 0 if right
     */
    SweepLine.isLeftPoints = function (point0, point1, point2) {
        return (point1.x - point0.x) * (point2.y - point0.y) - (point2.x - point0.x) * (point1.y - point0.y);
    };
    return SweepLine;
}());
exports.SweepLine = SweepLine;
//# sourceMappingURL=SweepLine.js.map