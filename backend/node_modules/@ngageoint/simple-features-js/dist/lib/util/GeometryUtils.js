"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryUtils = void 0;
var internal_1 = require("../internal");
/**
 * Utilities for Geometry objects
 */
var GeometryUtils = /** @class */ (function () {
    function GeometryUtils() {
    }
    /**
     * Get the dimension of the Geometry, 0 for points, 1 for curves, 2 for
     * surfaces. If a collection, the largest dimension is returned.
     * @param geometry geometry object
     * @return dimension (0, 1, or 2)
     */
    GeometryUtils.getDimension = function (geometry) {
        var dimension = -1;
        var geometryType = geometry.geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.POINT:
            case internal_1.GeometryType.MULTIPOINT:
                dimension = 0;
                break;
            case internal_1.GeometryType.LINESTRING:
            case internal_1.GeometryType.MULTILINESTRING:
            case internal_1.GeometryType.CIRCULARSTRING:
            case internal_1.GeometryType.COMPOUNDCURVE:
                dimension = 1;
                break;
            case internal_1.GeometryType.POLYGON:
            case internal_1.GeometryType.CURVEPOLYGON:
            case internal_1.GeometryType.MULTIPOLYGON:
            case internal_1.GeometryType.POLYHEDRALSURFACE:
            case internal_1.GeometryType.TIN:
            case internal_1.GeometryType.TRIANGLE:
                dimension = 2;
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                geometry.geometries.forEach(function (subGeometry) {
                    dimension = Math.max(dimension, GeometryUtils.getDimension(subGeometry));
                });
                break;
            default:
                throw new internal_1.SFException("Unsupported Geometry Type: " + geometryType);
        }
        return dimension;
    };
    /**
     * Get the Pythagorean theorem distance between two points
     * @param point1 point 1
     * @param point2 point 2
     * @return distance
     */
    GeometryUtils.distance = function (point1, point2) {
        var diffX = point1.x - point2.x;
        var diffY = point1.y - point2.y;
        return Math.sqrt(diffX * diffX + diffY * diffY);
    };
    /**
     * Get the Pythagorean theorem distance between the line end points
     *
     * @param line
     *            line
     * @return distance
     * @since 1.1.1
     */
    GeometryUtils.distanceFromLine = function (line) {
        return GeometryUtils.distance(line.startPoint(), line.endPoint());
    };
    /**
     * Get the bearing heading in degrees between two points in degrees
     *
     * @param point1
     *            point 1
     * @param point2
     *            point 2
     * @return bearing angle in degrees between 0 and 360
     * @since 1.1.1
     */
    GeometryUtils.bearing = function (point1, point2) {
        var y1 = GeometryUtils.degreesToRadians(point1.y);
        var y2 = GeometryUtils.degreesToRadians(point2.y);
        var xDiff = GeometryUtils.degreesToRadians(point2.x - point1.x);
        var y = Math.sin(xDiff) * Math.cos(y2);
        var x = Math.cos(y1) * Math.sin(y2)
            - Math.sin(y1) * Math.cos(y2) * Math.cos(xDiff);
        return (GeometryUtils.radiansToDegrees(Math.atan2(y, x)) + 360) % 360;
    };
    /**
     * Get the bearing heading in degrees between line end points in degrees
     *
     * @param line
     *            line
     * @return bearing angle in degrees between 0 inclusively and 360
     *         exclusively
     * @since 1.1.1
     */
    GeometryUtils.bearingLine = function (line) {
        return GeometryUtils.bearing(line.startPoint(), line.endPoint());
    };
    /**
     * Determine if the bearing is in any north direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if north bearing
     * @since 1.1.1
     */
    GeometryUtils.isNorthBearing = function (bearing) {
        bearing %= 360.0;
        return bearing < internal_1.GeometryConstants.BEARING_EAST
            || bearing > internal_1.GeometryConstants.BEARING_WEST;
    };
    /**
     * Determine if the bearing is in any east direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if east bearing
     * @since 1.1.1
     */
    GeometryUtils.isEastBearing = function (bearing) {
        bearing %= 360.0;
        return bearing > internal_1.GeometryConstants.BEARING_NORTH
            && bearing < internal_1.GeometryConstants.BEARING_SOUTH;
    };
    /**
     * Determine if the bearing is in any south direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if south bearing
     * @since 1.1.1
     */
    GeometryUtils.isSouthBearing = function (bearing) {
        bearing %= 360.0;
        return bearing > internal_1.GeometryConstants.BEARING_EAST
            && bearing < internal_1.GeometryConstants.BEARING_WEST;
    };
    /**
     * Determine if the bearing is in any west direction
     *
     * @param bearing
     *            bearing angle in degrees
     * @return true if west bearing
     * @since 1.1.1
     */
    GeometryUtils.isWestBearing = function (bearing) {
        return (bearing % 360.0) > internal_1.GeometryConstants.BEARING_SOUTH;
    };
    /**
     * Convert degrees to radians
     *
     * @param degrees
     *            degrees
     * @return radians
     * @since 1.1.1
     */
    GeometryUtils.degreesToRadians = function (degrees) {
        return degrees * internal_1.GeometryConstants.DEGREES_TO_RADIANS;
    };
    /**
     * Convert radians to degrees
     *
     * @param radians
     *            radians
     * @return degrees
     * @since 1.1.1
     */
    GeometryUtils.radiansToDegrees = function (radians) {
        return radians * internal_1.GeometryConstants.RADIANS_TO_DEGREES;
    };
    /**
     * Get the centroid point of a 2 dimensional representation of the Geometry
     * (balancing point of a 2d cutout of the geometry). Only the x and y
     * coordinate of the resulting point are calculated and populated. The
     * resulting {@link Point#getZ()} and {@link Point#getM()} methods will
     * always return null.
     * @param geometry geometry object
     * @return centroid point
     */
    GeometryUtils.getCentroid = function (geometry) {
        var centroid = null;
        var dimension = GeometryUtils.getDimension(geometry);
        switch (dimension) {
            case 0:
                var point = new internal_1.CentroidPoint(geometry);
                centroid = point.getCentroid();
                break;
            case 1:
                var curve = new internal_1.CentroidCurve(geometry);
                centroid = curve.getCentroid();
                break;
            case 2:
                var surface = new internal_1.CentroidSurface(geometry);
                centroid = surface.getCentroid();
                break;
        }
        return centroid;
    };
    /**
     * Get the geographic centroid point of a 2 dimensional representation of
     * the degree unit Geometry. Only the x and y coordinate of the resulting
     * point are calculated and populated. The resulting {@link Point#getZ()}
     * and {@link Point#getM()} methods will always return null.
     *
     * @param geometry  geometry object
     * @return centroid point
     */
    GeometryUtils.getDegreesCentroid = function (geometry) {
        return internal_1.DegreesCentroid.getCentroid(geometry);
    };
    /**
     * Minimize the WGS84 geometry using the shortest x distance between each
     * connected set of points. Resulting x values will be in the range: -540.0
     * &lt;= x &lt;= 540.0
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    GeometryUtils.minimizeWGS84 = function (geometry) {
        GeometryUtils.minimize(geometry, internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH);
    };
    /**
     * Minimize the Web Mercator geometry using the shortest x distance between
     * each connected set of points. Resulting x values will be in the range:
     * -60112525.028367732 &lt;= x &lt;= 60112525.028367732
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    GeometryUtils.minimizeWebMercator = function (geometry) {
        GeometryUtils.minimize(geometry, internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH);
    };
    /**
     * Minimize the geometry using the shortest x distance between each
     * connected set of points. The resulting geometry point x values will be in
     * the range: (3 * min value &lt;= x &lt;= 3 * max value
     *
     * Example: For WGS84 provide a max x of 180.0. Resulting x values will be
     * in the range: -540.0 &lt;= x &lt;= 540.0
     *
     * Example: For web mercator provide a world width of 20037508.342789244.
     * Resulting x values will be in the range: -60112525.028367732 &lt;= x
     * &lt;= 60112525.028367732
     *
     * @param geometry geometry
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizeGeometry = function (geometry, maxX) {
        GeometryUtils.minimize(geometry, maxX);
    };
    /**
     * Minimize the geometry using the shortest x distance between each
     * connected set of points. The resulting geometry point x values will be in
     * the range: (3 * min value &lt;= x &lt;= 3 * max value
     *
     * Example: For WGS84 provide a max x of
     * {@link GeometryConstants#WGS84_HALF_WORLD_LON_WIDTH}. Resulting x values
     * will be in the range: -540.0 &lt;= x &lt;= 540.0
     *
     * Example: For web mercator provide a world width of
     * {@link GeometryConstants#WEB_MERCATOR_HALF_WORLD_WIDTH}. Resulting x
     * values will be in the range: -60112525.028367732 &lt;= x &lt;=
     * 60112525.028367732
     *
     * @param geometry
     *            geometry
     * @param maxX
     *            max positive x value in the geometry projection
     * @since 1.1.1
     */
    GeometryUtils.minimize = function (geometry, maxX) {
        var e_1, _a;
        var geometryType = geometry.geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.LINESTRING:
                GeometryUtils.minimizeLineString(geometry, maxX);
                break;
            case internal_1.GeometryType.POLYGON:
                GeometryUtils.minimizePolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                GeometryUtils.minimizeMultiLineString(geometry, maxX);
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                GeometryUtils.minimizeMultiPolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                GeometryUtils.minimizeLineString(geometry, maxX);
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                GeometryUtils.minimizeCompoundCurve(geometry, maxX);
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                var curvePolygon = geometry;
                GeometryUtils.minimizeCurvePolygon(curvePolygon, maxX);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                GeometryUtils.minimizePolyhedralSurface(geometry, maxX);
                break;
            case internal_1.GeometryType.TIN:
                GeometryUtils.minimizePolyhedralSurface(geometry, maxX);
                break;
            case internal_1.GeometryType.TRIANGLE:
                GeometryUtils.minimizePolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                var geomCollection = geometry;
                try {
                    for (var _b = __values(geomCollection.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subGeometry = _c.value;
                        GeometryUtils.minimizeGeometry(subGeometry, maxX);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                break;
            default:
                break;
        }
    };
    /**
     * Minimize the line string
     *
     * @param lineString
     *            line string
     * @param maxX
     *            max positive x value in the geometry projection
     */
    GeometryUtils.minimizeLineString = function (lineString, maxX) {
        var points = lineString.points;
        if (points.length > 1) {
            var point = points[0];
            for (var i = 1; i < points.length; i++) {
                var nextPoint = points[i];
                if (point.x < nextPoint.x) {
                    if (nextPoint.x - point.x > point.x
                        - nextPoint.x + (maxX * 2.0)) {
                        nextPoint.x = nextPoint.x - (maxX * 2.0);
                    }
                }
                else if (point.x > nextPoint.x) {
                    if (point.x - nextPoint.x > nextPoint.x
                        - point.x + (maxX * 2.0)) {
                        nextPoint.x = nextPoint.x + (maxX * 2.0);
                    }
                }
            }
        }
    };
    /**
     * Minimize the multi line string
     * @param multiLineString multi line string
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizeMultiLineString = function (multiLineString, maxX) {
        multiLineString.lineStrings.forEach(function (lineString) { return GeometryUtils.minimizeLineString(lineString, maxX); });
    };
    /**
     * Minimize the polygon
     * @param polygon polygon
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizePolygon = function (polygon, maxX) {
        polygon.rings.forEach(function (ring) { return GeometryUtils.minimizeLineString(ring, maxX); });
    };
    /**
     * Minimize the multi polygon
     * @param multiPolygon multi polygon
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizeMultiPolygon = function (multiPolygon, maxX) {
        multiPolygon.polygons.forEach(function (polygon) { return GeometryUtils.minimizePolygon(polygon, maxX); });
    };
    /**
     * Minimize the compound curve
     * @param compoundCurve compound curve
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizeCompoundCurve = function (compoundCurve, maxX) {
        compoundCurve.lineStrings.forEach(function (lineString) { return GeometryUtils.minimizeLineString(lineString, maxX); });
    };
    /**
     * Minimize the curve polygon
     * @param curvePolygon curve polygon
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizeCurvePolygon = function (curvePolygon, maxX) {
        curvePolygon.rings.forEach(function (ring) { return GeometryUtils.minimizeGeometry(ring, maxX); });
    };
    /**
     * Minimize the polyhedral surface
     * @param polyhedralSurface polyhedral surface
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.minimizePolyhedralSurface = function (polyhedralSurface, maxX) {
        polyhedralSurface.polygons.forEach(function (polygon) { return GeometryUtils.minimizePolygon(polygon, maxX); });
    };
    /**
     * Normalize the WGS84 geometry using the shortest x distance between each
     * connected set of points. Resulting x values will be in the range: -180.0
     * &lt;= x &lt;= 180.0
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    GeometryUtils.normalizeWGS84 = function (geometry) {
        GeometryUtils.normalize(geometry, internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH);
    };
    /**
     * Normalize the Web Mercator geometry using the shortest x distance between
     * each connected set of points. Resulting x values will be in the range:
     * -20037508.342789244 &lt;= x &lt;= 20037508.342789244
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    GeometryUtils.normalizeWebMercator = function (geometry) {
        GeometryUtils.normalize(geometry, internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH);
    };
    /**
     * Normalize the geometry so all points outside of the min and max value
     * range are adjusted to fall within the range.
     *
     * Example: For WGS84 provide a max x of 180.0. Resulting x values will be
     * in the range: -180.0 &lt;= x &lt;= 180.0.
     *
     * Example: For web mercator provide a world width of 20037508.342789244.
     * Resulting x values will be in the range: -20037508.342789244 &lt;= x
     * &lt;= 20037508.342789244.
     *
     * @param geometry geometry
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizeGeometry = function (geometry, maxX) {
        GeometryUtils.normalize(geometry, maxX);
    };
    /**
     * Normalize the geometry so all points outside of the min and max value
     * range are adjusted to fall within the range.
     *
     * Example: For WGS84 provide a max x of
     * {@link GeometryConstants#WGS84_HALF_WORLD_LON_WIDTH}. Resulting x values
     * will be in the range: -180.0 &lt;= x &lt;= 180.0
     *
     * Example: For web mercator provide a world width of
     * {@link GeometryConstants#WEB_MERCATOR_HALF_WORLD_WIDTH}. Resulting x
     * values will be in the range: -20037508.342789244 &lt;= x &lt;=
     * 20037508.342789244
     *
     * @param geometry
     *            geometry
     * @param maxX
     *            max positive x value in the geometry projection
     * @since 1.1.1
     */
    GeometryUtils.normalize = function (geometry, maxX) {
        var e_2, _a;
        var geometryType = geometry.geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.POINT:
                GeometryUtils.normalizePoint(geometry, maxX);
                break;
            case internal_1.GeometryType.LINESTRING:
                GeometryUtils.normalizeLineString(geometry, maxX);
                break;
            case internal_1.GeometryType.POLYGON:
                GeometryUtils.normalizePolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.MULTIPOINT:
                GeometryUtils.normalizeMultiPoint(geometry, maxX);
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                GeometryUtils.normalizeMultiLineString(geometry, maxX);
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                GeometryUtils.normalizeMultiPolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                GeometryUtils.normalizeLineString(geometry, maxX);
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                GeometryUtils.normalizeCompoundCurve(geometry, maxX);
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                GeometryUtils.normalizeCurvePolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                GeometryUtils.normalizePolyhedralSurface(geometry, maxX);
                break;
            case internal_1.GeometryType.TIN:
                GeometryUtils.normalizePolyhedralSurface(geometry, maxX);
                break;
            case internal_1.GeometryType.TRIANGLE:
                GeometryUtils.normalizePolygon(geometry, maxX);
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                try {
                    for (var _b = __values(geometry.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subGeometry = _c.value;
                        GeometryUtils.normalizeGeometry(subGeometry, maxX);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                break;
            default:
                break;
        }
    };
    /**
     * Normalize the point
     *
     * @param point
     *            point
     * @param maxX
     *            max positive x value in the geometry projection
     */
    GeometryUtils.normalizePoint = function (point, maxX) {
        if (point.x < -maxX) {
            point.x = point.x + (maxX * 2.0);
        }
        else if (point.x > maxX) {
            point.x = point.x - (maxX * 2.0);
        }
    };
    /**
     * Normalize the multi point
     * @param multiPoint multi point
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizeMultiPoint = function (multiPoint, maxX) {
        multiPoint.points.forEach(function (point) { return GeometryUtils.normalizePoint(point, maxX); });
    };
    /**
     * Normalize the line string
     * @param lineString line string
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizeLineString = function (lineString, maxX) {
        lineString.points.forEach(function (point) { return GeometryUtils.normalizePoint(point, maxX); });
    };
    /**
     * Normalize the multi line string
     * @param multiLineString  multi line string
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizeMultiLineString = function (multiLineString, maxX) {
        multiLineString.lineStrings.forEach(function (lineString) { return GeometryUtils.normalizeLineString(lineString, maxX); });
    };
    /**
     * Normalize the polygon
     * @param polygon polygon
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizePolygon = function (polygon, maxX) {
        polygon.rings.forEach(function (ring) { return GeometryUtils.normalizeLineString(ring, maxX); });
    };
    /**
     * Normalize the multi polygon
     * @param multiPolygon  multi polygon
     * @param maxX  max positive x value in the geometry projection
     */
    GeometryUtils.normalizeMultiPolygon = function (multiPolygon, maxX) {
        multiPolygon.polygons.forEach(function (polygon) { return GeometryUtils.normalizePolygon(polygon, maxX); });
    };
    /**
     * Normalize the compound curve
     * @param compoundCurve compound curve
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizeCompoundCurve = function (compoundCurve, maxX) {
        compoundCurve.lineStrings.forEach(function (lineString) { return GeometryUtils.normalizeLineString(lineString, maxX); });
    };
    /**
     * Normalize the curve polygon
     * @param curvePolygon curve polygon
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizeCurvePolygon = function (curvePolygon, maxX) {
        curvePolygon.rings.forEach(function (ring) { return GeometryUtils.normalizeGeometry(ring, maxX); });
    };
    /**
     * Normalize the polyhedral surface
     * @param polyhedralSurface polyhedral surface
     * @param maxX max positive x value in the geometry projection
     */
    GeometryUtils.normalizePolyhedralSurface = function (polyhedralSurface, maxX) {
        polyhedralSurface.polygons.forEach(function (polygon) { return GeometryUtils.normalizePolygon(polygon, maxX); });
    };
    /**
     * Normalize the x value
     *
     * @param x
     *            x value
     * @param maxX
     *            max positive x value in the geometry projection
     */
    GeometryUtils.normalizeX = function (x, maxX) {
        if (x < -maxX) {
            x = x + (maxX * 2.0);
        }
        else if (x > maxX) {
            x = x - (maxX * 2.0);
        }
        return x;
    };
    /**
     * Simplify the ordered points (representing a line, polygon, etc) using the
     * Douglas Peucker algorithm to create a similar curve with fewer points.
     * Points should be in a meters unit type projection. The tolerance is the
     * minimum tolerated distance between consecutive points.
     *
     * @param points geometry points
     * @param tolerance minimum tolerance in meters for consecutive points
     * @return simplified points
     * @since 1.0.4
     */
    GeometryUtils.simplifyPoints = function (points, tolerance) {
        return GeometryUtils._simplifyPoints(points, tolerance, 0, points.length - 1);
    };
    /**
     * Simplify the ordered points (representing a line, polygon, etc) using the
     * Douglas Peucker algorithm to create a similar curve with fewer points.
     * Points should be in a meters unit type projection. The tolerance is the
     * minimum tolerated distance between consecutive points.
     *
     * @param points geometry points
     * @param tolerance minimum tolerance in meters for consecutive points
     * @param startIndex start index
     * @param endIndex end index
     * @return simplified points
     */
    GeometryUtils._simplifyPoints = function (points, tolerance, startIndex, endIndex) {
        var result;
        var dmax = 0.0;
        var index = 0;
        var startPoint = points[startIndex];
        var endPoint = points[endIndex];
        for (var i = startIndex + 1; i < endIndex; i++) {
            var point = points[i];
            var d = GeometryUtils.perpendicularDistance(point, startPoint, endPoint);
            if (d > dmax) {
                index = i;
                dmax = d;
            }
        }
        if (dmax > tolerance) {
            var recResults1 = GeometryUtils._simplifyPoints(points, tolerance, startIndex, index);
            var recResults2 = GeometryUtils._simplifyPoints(points, tolerance, index, endIndex);
            result = recResults1.slice(0, recResults1.length - 1);
            result.push.apply(result, __spreadArray([], __read(recResults2), false));
        }
        else {
            result = [];
            result.push(startPoint);
            result.push(endPoint);
        }
        return result;
    };
    /**
     * Calculate the perpendicular distance between the point and the line
     * represented by the start and end points. Points should be in a meters
     * unit type projection.
     *
     * @param point point
     * @param lineStart point representing the line start
     * @param lineEnd point representing the line end
     * @return distance in meters
     */
    GeometryUtils.perpendicularDistance = function (point, lineStart, lineEnd) {
        var x = point.x;
        var y = point.y;
        var startX = lineStart.x;
        var startY = lineStart.y;
        var endX = lineEnd.x;
        var endY = lineEnd.y;
        var vX = endX - startX;
        var vY = endY - startY;
        var wX = x - startX;
        var wY = y - startY;
        var c1 = wX * vX + wY * vY;
        var c2 = vX * vX + vY * vY;
        var x2;
        var y2;
        if (c1 <= 0) {
            x2 = startX;
            y2 = startY;
        }
        else if (c2 <= c1) {
            x2 = endX;
            y2 = endY;
        }
        else {
            var b = c1 / c2;
            x2 = startX + b * vX;
            y2 = startY + b * vY;
        }
        return Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));
    };
    /**
     * Check if the point is in the polygon
     * @param point point
     * @param polygon polygon
     * @return true if in the polygon
     */
    GeometryUtils.pointInPolygon = function (point, polygon) {
        return GeometryUtils.pointInPolygonWithEpsilon(point, polygon, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is in the polygon
     *
     * @param point point
     * @param polygon polygon
     * @param epsilon epsilon line tolerance
     * @return true if in the polygon
     */
    GeometryUtils.pointInPolygonWithEpsilon = function (point, polygon, epsilon) {
        var contains = false;
        var rings = polygon.rings;
        if (rings.length > 0) {
            contains = GeometryUtils.pointInPolygonRingWithEpsilon(point, rings[0], epsilon);
            if (contains) {
                // Check the holes
                for (var i = 1; i < rings.length; i++) {
                    if (GeometryUtils.pointInPolygonRingWithEpsilon(point, rings[i], epsilon)) {
                        contains = false;
                        break;
                    }
                }
            }
        }
        return contains;
    };
    /**
     * Check if the point is in the polygon ring
     *
     * @param point point
     * @param ring polygon ring
     * @return true if in the polygon
     */
    GeometryUtils.pointInPolygonRing = function (point, ring) {
        return GeometryUtils.pointInPolygonRingWithEpsilon(point, ring, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is in the polygon ring
     *
     * @param point point
     * @param ring polygon ring
     * @param epsilon epsilon line tolerance
     * @return true if in the polygon
     */
    GeometryUtils.pointInPolygonRingWithEpsilon = function (point, ring, epsilon) {
        return GeometryUtils.pointInPolygonRingPointsWithEpsilon(point, ring.points, epsilon);
    };
    /**
     * Check if the point is in the polygon points
     * @param point point
     * @param points polygon points
     * @return true if in the polygon
     */
    GeometryUtils.pointInPolygonRingPoints = function (point, points) {
        return GeometryUtils.pointInPolygonRingPointsWithEpsilon(point, points, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is in the polygon points
     * @param point point
     * @param points polygon points
     * @param epsilon epsilon line tolerance
     * @return true if in the polygon
     */
    GeometryUtils.pointInPolygonRingPointsWithEpsilon = function (point, points, epsilon) {
        var contains = false;
        var i = 0;
        var j = points.length - 1;
        if (GeometryUtils.closedPolygonPoints(points)) {
            j = i++;
        }
        for (; i < points.length; j = i++) {
            var point1 = points[i];
            var point2 = points[j];
            // Shortcut check if polygon contains the point within tolerance
            if (Math.abs(point1.x - point.x) <= epsilon && Math.abs(point1.y - point.y) <= epsilon) {
                contains = true;
                break;
            }
            if (((point1.y > point.y) !== (point2.y > point.y))
                && (point.x < (point2.x - point1.x) * (point.y - point1.y) / (point2.y - point1.y) + point1.x)) {
                contains = !contains;
            }
        }
        if (!contains) {
            // Check the polygon edges
            contains = GeometryUtils.pointOnPolygonEdgePoints(point, points);
        }
        return contains;
    };
    /**
     * Check if the point is on the polygon edge
     * @param point point
     * @param polygon polygon
     * @return true if on the polygon edge
     */
    GeometryUtils.pointOnPolygonEdge = function (point, polygon) {
        return GeometryUtils.pointOnPolygonEdgeWithEpsilon(point, polygon, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is on the polygon edge
     *
     * @param point point
     * @param polygon polygon
     * @param epsilon epsilon line tolerance
     * @return true if on the polygon edge
     */
    GeometryUtils.pointOnPolygonEdgeWithEpsilon = function (point, polygon, epsilon) {
        return polygon.numRings() > 0 && GeometryUtils.pointOnPolygonEdgeRingWithEpsilon(point, polygon.rings[0], epsilon);
    };
    /**
     * Check if the point is on the polygon ring edge
     * @param point point
     * @param ring polygon ring
     * @return true if on the polygon edge
     */
    GeometryUtils.pointOnPolygonEdgeRing = function (point, ring) {
        return GeometryUtils.pointOnPolygonEdgeRingWithEpsilon(point, ring, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is on the polygon ring edge
     *
     * @param point point
     * @param ring polygon ring
     * @param epsilon epsilon line tolerance
     * @return true if on the polygon edge
     */
    GeometryUtils.pointOnPolygonEdgeRingWithEpsilon = function (point, ring, epsilon) {
        return GeometryUtils.pointOnPolygonEdgePointsWithEpsilon(point, ring.points, epsilon);
    };
    /**
     * Check if the point is on the polygon ring edge points
     * @param point point
     * @param points polygon points
     * @return true if on the polygon edge
     */
    GeometryUtils.pointOnPolygonEdgePoints = function (point, points) {
        return GeometryUtils.pointOnPolygonEdgePointsWithEpsilon(point, points, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is on the polygon ring edge points
     * @param point point
     * @param points polygon points
     * @param epsilon epsilon line tolerance
     * @return true if on the polygon edge
     */
    GeometryUtils.pointOnPolygonEdgePointsWithEpsilon = function (point, points, epsilon) {
        return GeometryUtils.pointOnPathPointArray(point, points, epsilon, !GeometryUtils.closedPolygonPoints(points));
    };
    /**
     * Check if the polygon outer ring is explicitly closed, where the first and
     * last point are the same
     * @param polygon polygon
     * @return true if the first and last points are the same
     */
    GeometryUtils.closedPolygon = function (polygon) {
        return polygon.numRings() > 0 && GeometryUtils.closedPolygonRing(polygon.rings[0]);
    };
    /**
     * Check if the polygon ring is explicitly closed, where the first and last
     * point are the same
     * @param ring polygon ring
     * @return true if the first and last points are the same
     */
    GeometryUtils.closedPolygonRing = function (ring) {
        return GeometryUtils.closedPolygonPoints(ring.points);
    };
    /**
     * Check if the polygon ring points are explicitly closed, where the first
     * and last point are the same
     * @param points polygon ring points
     * @return true if the first and last points are the same
     */
    GeometryUtils.closedPolygonPoints = function (points) {
        var closed = false;
        if (points.length > 0) {
            var first = points[0];
            var last = points[points.length - 1];
            closed = first.x == last.x && first.y == last.y;
        }
        return closed;
    };
    /**
     * Check if the point is on the line
     * @param point point
     * @param line  line
     * @return true if on the line
     */
    GeometryUtils.pointOnLine = function (point, line) {
        return GeometryUtils.pointOnLineWithEpsilon(point, line, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is on the line
     * @param point point
     * @param line line
     * @param epsilon epsilon line tolerance
     * @return true if on the line
     */
    GeometryUtils.pointOnLineWithEpsilon = function (point, line, epsilon) {
        return GeometryUtils.pointOnLinePointsWithEpsilon(point, line.points, epsilon);
    };
    /**
     * Check if the point is on the line represented by the points
     * @param point point
     * @param points line points
     * @return true if on the line
     */
    GeometryUtils.pointOnLinePoints = function (point, points) {
        return GeometryUtils.pointOnLinePointsWithEpsilon(point, points, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is on the line represented by the points
     * @param point point
     * @param points line points
     * @param epsilon epsilon line tolerance
     * @return true if on the line
     */
    GeometryUtils.pointOnLinePointsWithEpsilon = function (point, points, epsilon) {
        return GeometryUtils.pointOnPathPointArray(point, points, epsilon, false);
    };
    /**
     * Check if the point is on the path between point 1 and point 2
     * @param point point
     * @param point1 path point 1
     * @param point2 path point 2
     * @return true if on the path
     */
    GeometryUtils.pointOnPath = function (point, point1, point2) {
        return GeometryUtils.pointOnPathWithEpsilon(point, point1, point2, GeometryUtils.DEFAULT_EPSILON);
    };
    /**
     * Check if the point is on the path between point 1 and point 2
     * @param point point
     * @param point1 path point 1
     * @param point2 path point 2
     * @param epsilon epsilon line tolerance
     * @return true if on the path
     */
    GeometryUtils.pointOnPathWithEpsilon = function (point, point1, point2, epsilon) {
        var contains = false;
        var x21 = point2.x - point1.x;
        var y21 = point2.y - point1.y;
        var xP1 = point.x - point1.x;
        var yP1 = point.y - point1.y;
        var dp = xP1 * x21 + yP1 * y21;
        if (dp >= 0.0) {
            var lengthP1 = xP1 * xP1 + yP1 * yP1;
            var length21 = x21 * x21 + y21 * y21;
            if (lengthP1 <= length21) {
                contains = Math.abs(dp * dp - lengthP1 * length21) <= epsilon;
            }
        }
        return contains;
    };
    /**
     * Check if the point is on the path between the points
     * @param point point
     * @param points path points
     * @param epsilon epsilon line tolerance
     * @param circular true if a path exists between the first and last point (a non explicitly closed polygon)
     * @return true if on the path
     */
    GeometryUtils.pointOnPathPointArray = function (point, points, epsilon, circular) {
        var onPath = false;
        var i = 0;
        var j = points.length - 1;
        if (!circular) {
            j = i++;
        }
        for (; i < points.length; j = i++) {
            var point1 = points[i];
            var point2 = points[j];
            if (GeometryUtils.pointOnPathWithEpsilon(point, point1, point2, epsilon)) {
                onPath = true;
                break;
            }
        }
        return onPath;
    };
    /**
     * Get the point intersection between two lines
     *
     * @param line1
     *            first line
     * @param line2
     *            second line
     * @return intersection point or null if no intersection
     * @since 1.1.1
     */
    GeometryUtils.intersectionLine = function (line1, line2) {
        return GeometryUtils.intersection(line1.startPoint(), line1.endPoint(), line2.startPoint(), line2.endPoint());
    };
    /**
     * Get the point intersection between end points of two lines
     *
     * @param line1Point1
     *            first point of the first line
     * @param line1Point2
     *            second point of the first line
     * @param line2Point1
     *            first point of the second line
     * @param line2Point2
     *            second point of the second line
     * @return intersection point or null if no intersection
     * @since 2.1.0
     */
    GeometryUtils.intersection = function (line1Point1, line1Point2, line2Point1, line2Point2) {
        var intersection = null;
        var a1 = line1Point2.y - line1Point1.y;
        var b1 = line1Point1.x - line1Point2.x;
        var c1 = a1 * (line1Point1.x) + b1 * (line1Point1.y);
        var a2 = line2Point2.y - line2Point1.y;
        var b2 = line2Point1.x - line2Point2.x;
        var c2 = a2 * (line2Point1.x) + b2 * (line2Point1.y);
        var determinant = a1 * b2 - a2 * b1;
        if (determinant != 0) {
            var x = (b2 * c1 - b1 * c2) / determinant;
            var y = (a1 * c2 - a2 * c1) / determinant;
            intersection = new internal_1.Point(x, y);
        }
        return intersection;
    };
    /**
     * Convert a geometry in degrees to a geometry in meters
     *
     * @param geometry
     *            geometry in degrees
     * @return geometry in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMeters = function (geometry) {
        var e_3, _a;
        var meters = null;
        switch (geometry.geometryType) {
            case internal_1.GeometryType.POINT:
                meters = GeometryUtils.degreesToMetersPoint(geometry);
                break;
            case internal_1.GeometryType.LINESTRING:
                meters = GeometryUtils.degreesToMetersLineString(geometry);
                break;
            case internal_1.GeometryType.POLYGON:
                meters = GeometryUtils.degreesToMetersPolygon(geometry);
                break;
            case internal_1.GeometryType.MULTIPOINT:
                meters = GeometryUtils.degreesToMetersMultiPoint(geometry);
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                meters = GeometryUtils.degreesToMetersMultiLineString(geometry);
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                meters = GeometryUtils.degreesToMetersMultiPolygon(geometry);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                meters = GeometryUtils.degreesToMetersCircularString(geometry);
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                meters = GeometryUtils.degreesToMetersCompundCurve(geometry);
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                var curvePolygon = geometry;
                meters = GeometryUtils.degreesToMetersCurvePolygon(curvePolygon);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                meters = GeometryUtils.degreesToMetersPolyhedralSurface(geometry);
                break;
            case internal_1.GeometryType.TIN:
                meters = GeometryUtils.degreesToMetersPolyhedralSurface(geometry);
                break;
            case internal_1.GeometryType.TRIANGLE:
                meters = GeometryUtils.degreesToMetersPolygon(geometry);
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                var metersCollection = new internal_1.GeometryCollection();
                var geomCollection = geometry;
                try {
                    for (var _b = __values(geomCollection.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subGeometry = _c.value;
                        metersCollection.addGeometry(GeometryUtils.degreesToMeters(subGeometry));
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                meters = metersCollection;
                break;
            default:
                break;
        }
        return meters;
    };
    /**
     * Convert a point in degrees to a point in meters
     *
     * @param point
     *            point in degrees
     * @return point in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersPoint = function (point) {
        var value = GeometryUtils.degreesToMetersCoord(point.x, point.y);
        value.z = point.z;
        value.m = point.m;
        return value;
    };
    /**
     * Convert a coordinate in degrees to a point in meters
     *
     * @param x
     *            x value in degrees
     * @param y
     *            y value in degrees
     * @return point in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersCoord = function (x, y) {
        x = GeometryUtils.normalizeX(x, internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH);
        y = Math.min(y, internal_1.GeometryConstants.WGS84_HALF_WORLD_LAT_HEIGHT);
        y = Math.max(y, internal_1.GeometryConstants.DEGREES_TO_METERS_MIN_LAT);
        var xValue = x * internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH
            / internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH;
        var yValue = Math.log(Math.tan((internal_1.GeometryConstants.WGS84_HALF_WORLD_LAT_HEIGHT + y) * Math.PI
            / (2 * internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH)))
            / (Math.PI / internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH);
        yValue = yValue * internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH
            / internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH;
        return new internal_1.Point(xValue, yValue);
    };
    /**
     * Convert a multi point in degrees to a multi point in meters
     *
     * @param multiPoint
     *            multi point in degrees
     * @return multi point in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersMultiPoint = function (multiPoint) {
        var e_4, _a;
        var meters = new internal_1.MultiPoint(multiPoint.hasZ, multiPoint.hasM);
        try {
            for (var _b = __values(multiPoint.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                meters.addPoint(GeometryUtils.degreesToMetersPoint(point));
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return meters;
    };
    /**
     * Convert a line string in degrees to a line string in meters
     *
     * @param lineString
     *            line string in degrees
     * @return line string in meters
     * @since 2.2.0
     */
    GeometryUtils.degreesToMetersLineString = function (lineString) {
        var e_5, _a;
        var meters = new internal_1.LineString(lineString.hasZ, lineString.hasM);
        try {
            for (var _b = __values(lineString.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                meters.addPoint(GeometryUtils.degreesToMetersPoint(point));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return meters;
    };
    /**
     * Convert a line in degrees to a line in meters
     *
     * @param line
     *            line in degrees
     * @return line in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersLine = function (line) {
        var e_6, _a;
        var meters = new internal_1.Line(line.hasZ, line.hasM);
        try {
            for (var _b = __values(line.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                meters.addPoint(GeometryUtils.degreesToMetersPoint(point));
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return meters;
    };
    /**
     * Convert a multi line string in degrees to a multi line string in meters
     *
     * @param multiLineString
     *            multi line string in degrees
     * @return multi line string in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersMultiLineString = function (multiLineString) {
        var e_7, _a;
        var meters = new internal_1.MultiLineString(multiLineString.hasZ, multiLineString.hasM);
        try {
            for (var _b = __values(multiLineString.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                meters.addLineString(GeometryUtils.degreesToMetersLineString(lineString));
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return meters;
    };
    /**
     * Convert a polygon in degrees to a polygon in meters
     *
     * @param polygon
     *            polygon in degrees
     * @return polygon in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersPolygon = function (polygon) {
        var e_8, _a;
        var meters = new internal_1.Polygon(polygon.hasZ, polygon.hasM);
        try {
            for (var _b = __values(polygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                meters.addRing(GeometryUtils.degreesToMetersLineString(ring));
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return meters;
    };
    /**
     * Convert a multi polygon in degrees to a multi polygon in meters
     *
     * @param multiPolygon
     *            multi polygon in degrees
     * @return multi polygon in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersMultiPolygon = function (multiPolygon) {
        var e_9, _a;
        var meters = new internal_1.MultiPolygon(multiPolygon.hasZ, multiPolygon.hasM);
        try {
            for (var _b = __values(multiPolygon.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                meters.addPolygon(GeometryUtils.degreesToMetersPolygon(polygon));
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return meters;
    };
    /**
     * Convert a circular string in degrees to a circular string in meters
     *
     * @param circularString
     *            circular string in degrees
     * @return circular string in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersCircularString = function (circularString) {
        var e_10, _a;
        var meters = new internal_1.CircularString(circularString.hasZ, circularString.hasM);
        try {
            for (var _b = __values(circularString.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                meters.addPoint(GeometryUtils.degreesToMetersPoint(point));
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        return meters;
    };
    /**
     * Convert a compound curve in degrees to a compound curve in meters
     *
     * @param compoundCurve
     *            compound curve in degrees
     * @return compound curve in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersCompundCurve = function (compoundCurve) {
        var e_11, _a;
        var meters = new internal_1.CompoundCurve(compoundCurve.hasZ, compoundCurve.hasM);
        try {
            for (var _b = __values(compoundCurve.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                meters.addLineString(GeometryUtils.degreesToMetersLineString(lineString));
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return meters;
    };
    /**
     * Convert a curve polygon in degrees to a curve polygon in meters
     *
     * @param curvePolygon
     *            curve polygon in degrees
     * @return curve polygon in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersCurvePolygon = function (curvePolygon) {
        var e_12, _a;
        var meters = new internal_1.CurvePolygon(curvePolygon.hasZ, curvePolygon.hasM);
        try {
            for (var _b = __values(curvePolygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                meters.addRing(GeometryUtils.degreesToMeters(ring));
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_12) throw e_12.error; }
        }
        return meters;
    };
    /**
     * Convert a polyhedral surface in degrees to a polyhedral surface in meters
     *
     * @param polyhedralSurface
     *            polyhedral surface in degrees
     * @return polyhedral surface in meters
     * @since 1.1.1
     */
    GeometryUtils.degreesToMetersPolyhedralSurface = function (polyhedralSurface) {
        var e_13, _a;
        var meters = new internal_1.PolyhedralSurface(polyhedralSurface.hasZ, polyhedralSurface.hasM);
        try {
            for (var _b = __values(polyhedralSurface.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                meters.addPolygon(GeometryUtils.degreesToMetersPolygon(polygon));
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_13) throw e_13.error; }
        }
        return meters;
    };
    /**
     * Convert a geometry in meters to a geometry in degrees
     *
     * @param geometry
     *            geometry in meters
     * @return geometry in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegrees = function (geometry) {
        var e_14, _a;
        var degrees = null;
        switch (geometry.geometryType) {
            case internal_1.GeometryType.POINT:
                degrees = GeometryUtils.metersToDegreesPoint(geometry);
                break;
            case internal_1.GeometryType.LINESTRING:
                degrees = GeometryUtils.metersToDegreesLineString(geometry);
                break;
            case internal_1.GeometryType.POLYGON:
                degrees = GeometryUtils.metersToDegreesPolygon(geometry);
                break;
            case internal_1.GeometryType.MULTIPOINT:
                degrees = GeometryUtils.metersToDegreesMultiPoint(geometry);
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                degrees = GeometryUtils.metersToDegreesMultiLineString(geometry);
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                degrees = GeometryUtils.metersToDegreesMultiPolygon(geometry);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                degrees = GeometryUtils.metersToDegreesCircularString(geometry);
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                degrees = GeometryUtils.metersToDegreesCompoundCurve(geometry);
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                var curvePolygon = geometry;
                degrees = GeometryUtils.metersToDegreesCurvePolygon(curvePolygon);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                degrees = GeometryUtils.metersToDegreesPolyhedralSurface(geometry);
                break;
            case internal_1.GeometryType.TIN:
                degrees = GeometryUtils.metersToDegreesPolyhedralSurface(geometry);
                break;
            case internal_1.GeometryType.TRIANGLE:
                degrees = GeometryUtils.degreesToMetersPolygon(geometry);
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                var degreesCollection = new internal_1.GeometryCollection();
                var geomCollection = geometry;
                try {
                    for (var _b = __values(geomCollection.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subGeometry = _c.value;
                        degreesCollection.addGeometry(GeometryUtils.metersToDegrees(subGeometry));
                    }
                }
                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_14) throw e_14.error; }
                }
                degrees = degreesCollection;
                break;
            default:
                break;
        }
        return degrees;
    };
    /**
     * Convert a point in meters to a point in degrees
     *
     * @param point
     *            point in meters
     * @return point in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesPoint = function (point) {
        var value = GeometryUtils.metersToDegreesCoord(point.x, point.y);
        value.z = point.z;
        value.m = point.m;
        return value;
    };
    /**
     * Convert a coordinate in meters to a point in degrees
     *
     * @param x
     *            x value in meters
     * @param y
     *            y value in meters
     * @return point in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesCoord = function (x, y) {
        var xValue = x * internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH
            / internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH;
        var yValue = y * internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH
            / internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH;
        yValue = Math.atan(Math.exp(yValue
            * (Math.PI / internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH)))
            / Math.PI * (2 * internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH)
            - internal_1.GeometryConstants.WGS84_HALF_WORLD_LAT_HEIGHT;
        return new internal_1.Point(xValue, yValue);
    };
    /**
     * Convert a multi point in meters to a multi point in degrees
     *
     * @param multiPoint
     *            multi point in meters
     * @return multi point in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesMultiPoint = function (multiPoint) {
        var e_15, _a;
        var degrees = new internal_1.MultiPoint(multiPoint.hasZ, multiPoint.hasM);
        try {
            for (var _b = __values(multiPoint.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                degrees.addPoint(GeometryUtils.metersToDegreesPoint(point));
            }
        }
        catch (e_15_1) { e_15 = { error: e_15_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_15) throw e_15.error; }
        }
        return degrees;
    };
    /**
     * Convert a line string in meters to a line string in degrees
     *
     * @param lineString
     *            line string in meters
     * @return line string in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesLineString = function (lineString) {
        var e_16, _a;
        var degrees = new internal_1.LineString(lineString.hasZ, lineString.hasM);
        try {
            for (var _b = __values(lineString.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                degrees.addPoint(GeometryUtils.metersToDegreesPoint(point));
            }
        }
        catch (e_16_1) { e_16 = { error: e_16_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_16) throw e_16.error; }
        }
        return degrees;
    };
    /**
     * Convert a line in meters to a line in degrees
     *
     * @param line
     *            line in meters
     * @return line in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesLine = function (line) {
        var e_17, _a;
        var degrees = new internal_1.Line(line.hasZ, line.hasM);
        try {
            for (var _b = __values(line.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                degrees.addPoint(GeometryUtils.metersToDegreesPoint(point));
            }
        }
        catch (e_17_1) { e_17 = { error: e_17_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_17) throw e_17.error; }
        }
        return degrees;
    };
    /**
     * Convert a multi line string in meters to a multi line string in degrees
     *
     * @param multiLineString
     *            multi line string in meters
     * @return multi line string in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesMultiLineString = function (multiLineString) {
        var e_18, _a;
        var degrees = new internal_1.MultiLineString(multiLineString.hasZ, multiLineString.hasM);
        try {
            for (var _b = __values(multiLineString.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                degrees.addLineString(GeometryUtils.metersToDegreesLineString(lineString));
            }
        }
        catch (e_18_1) { e_18 = { error: e_18_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_18) throw e_18.error; }
        }
        return degrees;
    };
    /**
     * Convert a polygon in meters to a polygon in degrees
     *
     * @param polygon
     *            polygon in meters
     * @return polygon in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesPolygon = function (polygon) {
        var e_19, _a;
        var degrees = new internal_1.Polygon(polygon.hasZ, polygon.hasM);
        try {
            for (var _b = __values(polygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                degrees.addRing(GeometryUtils.metersToDegreesLineString(ring));
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_19) throw e_19.error; }
        }
        return degrees;
    };
    /**
     * Convert a multi polygon in meters to a multi polygon in degrees
     *
     * @param multiPolygon
     *            multi polygon in meters
     * @return multi polygon in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesMultiPolygon = function (multiPolygon) {
        var e_20, _a;
        var degrees = new internal_1.MultiPolygon(multiPolygon.hasZ, multiPolygon.hasM);
        try {
            for (var _b = __values(multiPolygon.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                degrees.addPolygon(GeometryUtils.metersToDegreesPolygon(polygon));
            }
        }
        catch (e_20_1) { e_20 = { error: e_20_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_20) throw e_20.error; }
        }
        return degrees;
    };
    /**
     * Convert a circular string in meters to a circular string in degrees
     *
     * @param circularString
     *            circular string in meters
     * @return circular string in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesCircularString = function (circularString) {
        var e_21, _a;
        var degrees = new internal_1.CircularString(circularString.hasZ, circularString.hasM);
        try {
            for (var _b = __values(circularString.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                degrees.addPoint(GeometryUtils.metersToDegreesPoint(point));
            }
        }
        catch (e_21_1) { e_21 = { error: e_21_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_21) throw e_21.error; }
        }
        return degrees;
    };
    /**
     * Convert a compound curve in meters to a compound curve in degrees
     *
     * @param compoundCurve
     *            compound curve in meters
     * @return compound curve in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesCompoundCurve = function (compoundCurve) {
        var e_22, _a;
        var degrees = new internal_1.CompoundCurve(compoundCurve.hasZ, compoundCurve.hasM);
        try {
            for (var _b = __values(compoundCurve.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                degrees.addLineString(GeometryUtils.metersToDegreesLineString(lineString));
            }
        }
        catch (e_22_1) { e_22 = { error: e_22_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_22) throw e_22.error; }
        }
        return degrees;
    };
    /**
     * Convert a curve polygon in meters to a curve polygon in degrees
     *
     * @param curvePolygon
     *            curve polygon in meters
     * @return curve polygon in degrees
     * @since 2.2.0
     */
    GeometryUtils.metersToDegreesCurvePolygon = function (curvePolygon) {
        var e_23, _a;
        var degrees = new internal_1.CurvePolygon(curvePolygon.hasZ, curvePolygon.hasM);
        try {
            for (var _b = __values(curvePolygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                degrees.addRing(GeometryUtils.metersToDegrees(ring));
            }
        }
        catch (e_23_1) { e_23 = { error: e_23_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_23) throw e_23.error; }
        }
        return degrees;
    };
    /**
     * Convert a polyhedral surface in meters to a polyhedral surface in degrees
     *
     * @param polyhedralSurface
     *            polyhedral surface in meters
     * @return polyhedral surface in degrees
     * @since 1.1.1
     */
    GeometryUtils.metersToDegreesPolyhedralSurface = function (polyhedralSurface) {
        var e_24, _a;
        var degrees = new internal_1.PolyhedralSurface(polyhedralSurface.hasZ, polyhedralSurface.hasM);
        try {
            for (var _b = __values(polyhedralSurface.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                degrees.addPolygon(GeometryUtils.metersToDegreesPolygon(polygon));
            }
        }
        catch (e_24_1) { e_24 = { error: e_24_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_24) throw e_24.error; }
        }
        return degrees;
    };
    /**
     * Get a WGS84 bounded geometry envelope
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.wgs84Envelope = function () {
        return new internal_1.GeometryEnvelope(-internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH, -internal_1.GeometryConstants.WGS84_HALF_WORLD_LAT_HEIGHT, internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH, internal_1.GeometryConstants.WGS84_HALF_WORLD_LAT_HEIGHT);
    };
    /**
     * Get a WGS84 bounded geometry envelope used for projection transformations
     * (degrees to meters)
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.wgs84TransformableEnvelope = function () {
        return new internal_1.GeometryEnvelope(-internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH, internal_1.GeometryConstants.DEGREES_TO_METERS_MIN_LAT, internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH, internal_1.GeometryConstants.WGS84_HALF_WORLD_LAT_HEIGHT);
    };
    /**
     * Get a Web Mercator bounded geometry envelope
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.webMercatorEnvelope = function () {
        return new internal_1.GeometryEnvelope(-internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH, -internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH, internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH, internal_1.GeometryConstants.WEB_MERCATOR_HALF_WORLD_WIDTH);
    };
    /**
     * Get a WGS84 geometry envelope with Web Mercator bounds
     *
     * @return geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.wgs84EnvelopeWithWebMercator = function () {
        return new internal_1.GeometryEnvelope(-internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH, internal_1.GeometryConstants.WEB_MERCATOR_MIN_LAT_RANGE, internal_1.GeometryConstants.WGS84_HALF_WORLD_LON_WIDTH, internal_1.GeometryConstants.WEB_MERCATOR_MAX_LAT_RANGE);
    };
    /**
     * Crop the geometry in meters by web mercator world bounds. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param geometry
     *            geometry in meters
     * @return cropped geometry in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropWebMercator = function (geometry) {
        return GeometryUtils.crop(geometry, GeometryUtils.webMercatorEnvelope());
    };
    /**
     * Crop the geometry in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param geometry
     *            geometry in meters
     * @param envelope
     *            envelope in meters
     * @return cropped geometry in meters or null
     * @since 1.1.1
     */
    GeometryUtils.crop = function (geometry, envelope) {
        var e_25, _a;
        var crop = null;
        if (GeometryUtils.containsGeometryEnvelope(envelope, geometry.getEnvelope())) {
            crop = geometry;
        }
        else {
            switch (geometry.geometryType) {
                case internal_1.GeometryType.POINT:
                    crop = GeometryUtils.cropPoint(geometry, envelope);
                    break;
                case internal_1.GeometryType.LINESTRING:
                    crop = GeometryUtils.cropLineString(geometry, envelope);
                    break;
                case internal_1.GeometryType.POLYGON:
                    crop = GeometryUtils.cropPolygon(geometry, envelope);
                    break;
                case internal_1.GeometryType.MULTIPOINT:
                    crop = GeometryUtils.cropMultiPoint(geometry, envelope);
                    break;
                case internal_1.GeometryType.MULTILINESTRING:
                    crop = GeometryUtils.cropMultiLineString(geometry, envelope);
                    break;
                case internal_1.GeometryType.MULTIPOLYGON:
                    crop = GeometryUtils.cropMultiPolygon(geometry, envelope);
                    break;
                case internal_1.GeometryType.CIRCULARSTRING:
                    crop = GeometryUtils.cropCircularString(geometry, envelope);
                    break;
                case internal_1.GeometryType.COMPOUNDCURVE:
                    crop = GeometryUtils.cropCompoundCurve(geometry, envelope);
                    break;
                case internal_1.GeometryType.CURVEPOLYGON:
                    var curvePolygon = geometry;
                    crop = GeometryUtils.cropCurvePolygon(curvePolygon, envelope);
                    break;
                case internal_1.GeometryType.POLYHEDRALSURFACE:
                    crop = GeometryUtils.cropPolyhedralSurface(geometry, envelope);
                    break;
                case internal_1.GeometryType.TIN:
                    crop = GeometryUtils.cropPolyhedralSurface(geometry, envelope);
                    break;
                case internal_1.GeometryType.TRIANGLE:
                    crop = GeometryUtils.cropPolygon(geometry, envelope);
                    break;
                case internal_1.GeometryType.GEOMETRYCOLLECTION:
                case internal_1.GeometryType.MULTICURVE:
                case internal_1.GeometryType.MULTISURFACE:
                    var cropCollection = new internal_1.GeometryCollection();
                    var geomCollection = geometry;
                    try {
                        for (var _b = __values(geomCollection.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var subGeometry = _c.value;
                            cropCollection.addGeometry(GeometryUtils.crop(subGeometry, envelope));
                        }
                    }
                    catch (e_25_1) { e_25 = { error: e_25_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_25) throw e_25.error; }
                    }
                    crop = cropCollection;
                    break;
                default:
                    break;
            }
        }
        return crop;
    };
    /**
     * Crop the point by the envelope bounds.
     *
     * @param point
     *            point
     * @param envelope
     *            envelope
     * @return cropped point or null
     * @since 1.1.1
     */
    GeometryUtils.cropPoint = function (point, envelope) {
        var crop = null;
        if (GeometryUtils.containsPoint(envelope, point)) {
            crop = new internal_1.Point(point);
        }
        return crop;
    };
    /**
     * Crop the list of consecutive points in meters by the envelope bounds in
     * meters. Cropping removes points outside the envelope and creates new
     * points on the line intersections with the envelope.
     *
     * @param points
     *            consecutive points
     * @param envelope
     *            envelope in meters
     * @return cropped points in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropPoints = function (points, envelope) {
        var e_26, _a;
        var crop = [];
        var left = envelope.getLeft();
        var bottom = envelope.getBottom();
        var right = envelope.getRight();
        var top = envelope.getTop();
        var previousPoint = null;
        var previousContains = false;
        try {
            for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                var point = points_1_1.value;
                var contains = GeometryUtils.containsPoint(envelope, point);
                if (previousPoint != null && (!contains || !previousContains)) {
                    var line = new internal_1.Line(previousPoint, point);
                    var bearing = GeometryUtils.bearingLine(GeometryUtils.metersToDegreesLine(line));
                    var westBearing = GeometryUtils.isWestBearing(bearing);
                    var eastBearing = GeometryUtils.isEastBearing(bearing);
                    var southBearing = GeometryUtils.isSouthBearing(bearing);
                    var northBearing = GeometryUtils.isNorthBearing(bearing);
                    var vertLine = null;
                    if (point.x > envelope.maxX) {
                        if (eastBearing) {
                            vertLine = right;
                        }
                    }
                    else if (point.x < envelope.minX) {
                        if (westBearing) {
                            vertLine = left;
                        }
                    }
                    else if (eastBearing) {
                        vertLine = left;
                    }
                    else if (westBearing) {
                        vertLine = right;
                    }
                    var horizLine = null;
                    if (point.y > envelope.maxY) {
                        if (northBearing) {
                            horizLine = top;
                        }
                    }
                    else if (point.y < envelope.minY) {
                        if (southBearing) {
                            horizLine = bottom;
                        }
                    }
                    else if (northBearing) {
                        horizLine = bottom;
                    }
                    else if (southBearing) {
                        horizLine = top;
                    }
                    var vertIntersection = null;
                    if (vertLine != null) {
                        vertIntersection = GeometryUtils.intersectionLine(line, vertLine);
                        if (vertIntersection != null
                            && !GeometryUtils.containsGeometryEnvelope(envelope, vertIntersection)) {
                            vertIntersection = null;
                        }
                    }
                    var horizIntersection = null;
                    if (horizLine != null) {
                        horizIntersection = GeometryUtils.intersectionLine(line, horizLine);
                        if (horizIntersection != null
                            && !GeometryUtils.containsGeometryEnvelope(envelope, horizIntersection)) {
                            horizIntersection = null;
                        }
                    }
                    var intersection1 = null;
                    var intersection2 = null;
                    if (vertIntersection != null && horizIntersection != null) {
                        var vertDistance = GeometryUtils.distance(previousPoint, vertIntersection);
                        var horizDistance = GeometryUtils.distance(previousPoint, horizIntersection);
                        if (vertDistance <= horizDistance) {
                            intersection1 = vertIntersection;
                            intersection2 = horizIntersection;
                        }
                        else {
                            intersection1 = horizIntersection;
                            intersection2 = vertIntersection;
                        }
                    }
                    else if (vertIntersection != null) {
                        intersection1 = vertIntersection;
                    }
                    else {
                        intersection1 = horizIntersection;
                    }
                    if (intersection1 != null && !GeometryUtils.isEqual(intersection1, point)
                        && !GeometryUtils.isEqual(intersection1, previousPoint)) {
                        crop.push(intersection1);
                        if (!contains && !previousContains && intersection2 != null
                            && !GeometryUtils.isEqual(intersection2, intersection1)) {
                            crop.push(intersection2);
                        }
                    }
                }
                if (contains) {
                    crop.push(point);
                }
                previousPoint = point;
                previousContains = contains;
            }
        }
        catch (e_26_1) { e_26 = { error: e_26_1 }; }
        finally {
            try {
                if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
            }
            finally { if (e_26) throw e_26.error; }
        }
        if (crop.length > 0) {
            crop = null;
        }
        else if (crop.length > 1) {
            if (points[0].equals(points[points.length - 1])
                && !crop[0].equals(crop[crop.length - 1])) {
                crop.push(new internal_1.Point(crop[0]));
            }
            if (crop.length > 2) {
                var simplified = [];
                simplified.push(crop[0]);
                for (var i = 1; i < crop.length - 1; i++) {
                    var previous = simplified[length - 1];
                    var point = crop[i];
                    var next = crop[i + 1];
                    if (!GeometryUtils.pointOnPath(point, previous, next)) {
                        simplified.push(point);
                    }
                }
                simplified.push(crop[crop.length - 1]);
                crop = simplified;
            }
        }
        return crop;
    };
    /**
     * Crop the multi point by the envelope bounds.
     *
     * @param multiPoint
     *            multi point
     * @param envelope
     *            envelope
     * @return cropped multi point or null
     * @since 1.1.1
     */
    GeometryUtils.cropMultiPoint = function (multiPoint, envelope) {
        var e_27, _a;
        var crop = null;
        var cropPoints = [];
        try {
            for (var _b = __values(multiPoint.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                var cropPoint = GeometryUtils.cropPoint(point, envelope);
                if (cropPoint != null) {
                    cropPoints.push(cropPoint);
                }
            }
        }
        catch (e_27_1) { e_27 = { error: e_27_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_27) throw e_27.error; }
        }
        if (cropPoints.length > 0) {
            crop = new internal_1.MultiPoint(multiPoint.hasZ, multiPoint.hasM);
            crop.points = cropPoints;
        }
        return crop;
    };
    /**
     * Crop the line string in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param lineString
     *            line string in meters
     * @param envelope
     *            envelope in meters
     * @return cropped line string in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropLineString = function (lineString, envelope) {
        var crop = null;
        var cropPoints = GeometryUtils.cropPoints(lineString.points, envelope);
        if (cropPoints != null) {
            crop = new internal_1.LineString(lineString.hasZ, lineString.hasM);
            crop.points = cropPoints;
        }
        return crop;
    };
    /**
     * Crop the line in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param line
     *            line in meters
     * @param envelope
     *            envelope in meters
     * @return cropped line in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropLine = function (line, envelope) {
        var crop = null;
        var cropPoints = GeometryUtils.cropPoints(line.points, envelope);
        if (cropPoints != null) {
            crop = new internal_1.Line(line.hasZ, line.hasM);
            crop.points = cropPoints;
        }
        return crop;
    };
    /**
     * Crop the multi line string in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param multiLineString
     *            multi line string in meters
     * @param envelope
     *            envelope in meters
     * @return cropped multi line string in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropMultiLineString = function (multiLineString, envelope) {
        var e_28, _a;
        var crop = null;
        var cropLineStrings = [];
        try {
            for (var _b = __values(multiLineString.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                var cropLineString = GeometryUtils.cropLineString(lineString, envelope);
                if (cropLineString != null) {
                    cropLineStrings.push(cropLineString);
                }
            }
        }
        catch (e_28_1) { e_28 = { error: e_28_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_28) throw e_28.error; }
        }
        if (cropLineStrings.length > 0) {
            crop = new internal_1.MultiLineString(multiLineString.hasZ, multiLineString.hasM);
            crop.lineStrings = cropLineStrings;
        }
        return crop;
    };
    /**
     * Crop the polygon in meters by the envelope bounds in meters. Cropping
     * removes points outside the envelope and creates new points on the line
     * intersections with the envelope.
     *
     * @param polygon
     *            polygon in meters
     * @param envelope
     *            envelope in meters
     * @return cropped polygon in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropPolygon = function (polygon, envelope) {
        var e_29, _a;
        var crop = null;
        var cropRings = [];
        try {
            for (var _b = __values(polygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                var points = ring.points;
                if (!ring.isClosed()) {
                    points.push(new internal_1.Point(points[0]));
                }
                var cropPoints = GeometryUtils.cropPoints(points, envelope);
                if (cropPoints != null) {
                    var cropRing = new internal_1.LineString(ring.hasZ, ring.hasM);
                    cropRing.points = cropPoints;
                    cropRings.push(cropRing);
                }
            }
        }
        catch (e_29_1) { e_29 = { error: e_29_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_29) throw e_29.error; }
        }
        if (cropRings.length > 0) {
            crop = new internal_1.Polygon(polygon.hasZ, polygon.hasM);
            crop.rings = cropRings;
        }
        return crop;
    };
    /**
     * Crop the multi polygon in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param multiPolygon
     *            multi polygon in meters
     * @param envelope
     *            envelope in meters
     * @return cropped multi polygon in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropMultiPolygon = function (multiPolygon, envelope) {
        var e_30, _a;
        var crop = null;
        var cropPolygons = [];
        try {
            for (var _b = __values(multiPolygon.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                var cropPolygon = GeometryUtils.cropPolygon(polygon, envelope);
                if (cropPolygon != null) {
                    cropPolygons.push(cropPolygon);
                }
            }
        }
        catch (e_30_1) { e_30 = { error: e_30_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_30) throw e_30.error; }
        }
        if (cropPolygons.length > 0) {
            crop = new internal_1.MultiPolygon(multiPolygon.hasZ, multiPolygon.hasM);
            crop.polygons = cropPolygons;
        }
        return crop;
    };
    /**
     * Crop the circular string in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param circularString
     *            circular string in meters
     * @param envelope
     *            envelope in meters
     * @return cropped circular string in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropCircularString = function (circularString, envelope) {
        var crop = null;
        var cropPoints = GeometryUtils.cropPoints(circularString.points, envelope);
        if (cropPoints != null) {
            crop = new internal_1.CircularString(circularString.hasZ, circularString.hasM);
            crop.points = cropPoints;
        }
        return crop;
    };
    /**
     * Crop the compound curve in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param compoundCurve
     *            compound curve in meters
     * @param envelope
     *            envelope in meters
     * @return cropped compound curve in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropCompoundCurve = function (compoundCurve, envelope) {
        var e_31, _a;
        var crop = null;
        var cropLineStrings = [];
        try {
            for (var _b = __values(compoundCurve.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                var cropLineString = GeometryUtils.cropLineString(lineString, envelope);
                if (cropLineString != null) {
                    cropLineStrings.push(cropLineString);
                }
            }
        }
        catch (e_31_1) { e_31 = { error: e_31_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_31) throw e_31.error; }
        }
        if (cropLineStrings.length > 0) {
            crop = new internal_1.CompoundCurve(compoundCurve.hasZ, compoundCurve.hasM);
            crop.lineStrings = cropLineStrings;
        }
        return crop;
    };
    /**
     * Crop the curve polygon in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param curvePolygon
     *            curve polygon in meters
     * @param envelope
     *            envelope in meters
     * @return cropped curve polygon in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropCurvePolygon = function (curvePolygon, envelope) {
        var e_32, _a;
        var crop = null;
        var cropRings = [];
        try {
            for (var _b = __values(curvePolygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                var cropRing = GeometryUtils.crop(ring, envelope);
                if (cropRing != null) {
                    cropRings.push(cropRing);
                }
            }
        }
        catch (e_32_1) { e_32 = { error: e_32_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_32) throw e_32.error; }
        }
        if (cropRings.length > 0) {
            crop = new internal_1.CurvePolygon(curvePolygon.hasZ, curvePolygon.hasM);
            crop.rings = cropRings;
        }
        return crop;
    };
    /**
     * Crop the polyhedral surface in meters by the envelope bounds in meters.
     * Cropping removes points outside the envelope and creates new points on
     * the line intersections with the envelope.
     *
     * @param polyhedralSurface
     *            polyhedral surface in meters
     * @param envelope
     *            envelope in meters
     * @return cropped polyhedral surface in meters or null
     * @since 1.1.1
     */
    GeometryUtils.cropPolyhedralSurface = function (polyhedralSurface, envelope) {
        var e_33, _a;
        var crop = null;
        var cropPolygons = [];
        try {
            for (var _b = __values(polyhedralSurface.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                var cropPolygon = GeometryUtils.cropPolygon(polygon, envelope);
                if (cropPolygon != null) {
                    cropPolygons.push(cropPolygon);
                }
            }
        }
        catch (e_33_1) { e_33 = { error: e_33_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_33) throw e_33.error; }
        }
        if (cropPolygons.length > 0) {
            crop = new internal_1.PolyhedralSurface(polyhedralSurface.hasZ, polyhedralSurface.hasM);
            crop.polygons = cropPolygons;
        }
        return crop;
    };
    /**
     * Determine if the points are equal within the default tolerance of
     * {@link GeometryConstants#DEFAULT_EQUAL_EPSILON}. For exact equality, use
     * {@link Point#equals(Object)}.
     *
     * @param point1
     *            point 1
     * @param point2
     *            point 2
     * @return true if equal
     * @since 1.1.1
     */
    GeometryUtils.isEqual = function (point1, point2) {
        return GeometryUtils.isEqualWithEpsilon(point1, point2, internal_1.GeometryConstants.DEFAULT_EQUAL_EPSILON);
    };
    /**
     * Determine if the points are equal within the tolerance. For exact
     * equality, use {@link Point#equals(Object)}.
     *
     * @param point1
     *            point 1
     * @param point2
     *            point 2
     * @param epsilon
     *            epsilon equality tolerance
     * @return true if equal
     * @since 1.1.1
     */
    GeometryUtils.isEqualWithEpsilon = function (point1, point2, epsilon) {
        var equal = Math.abs(point1.x - point2.x) <= epsilon
            && Math.abs(point1.y - point2.y) <= epsilon
            && point1.hasZ == point2.hasZ
            && point1.hasM == point2.hasM;
        if (equal) {
            if (point1.hasZ) {
                equal = Math.abs(point1.z - point2.z) <= epsilon;
            }
            if (equal && point1.hasM) {
                equal = Math.abs(point1.m - point2.m) <= epsilon;
            }
        }
        return equal;
    };
    /**
     * Determine if the envelope contains the point within the default tolerance
     * of {@link GeometryConstants#DEFAULT_EQUAL_EPSILON}. For exact equality,
     * use {@link GeometryEnvelope#contains(Point)}.
     *
     * @param envelope
     *            envelope
     * @param point
     *            point
     * @return true if contains
     * @since 1.1.1
     */
    GeometryUtils.containsPoint = function (envelope, point) {
        return envelope.containsPointWithEpsilon(point, internal_1.GeometryConstants.DEFAULT_EQUAL_EPSILON);
    };
    /**
     * Determine if the first envelope contains the second within the default
     * tolerance of {@link GeometryConstants#DEFAULT_EQUAL_EPSILON}. For exact
     * equality, use {@link GeometryEnvelope#contains(GeometryEnvelope)}.
     *
     * @param envelope1
     *            envelope 1
     * @param envelope2
     *            envelope 2
     * @return true if contains
     * @since 1.1.1
     */
    GeometryUtils.containsGeometryEnvelope = function (envelope1, envelope2) {
        return envelope1.containsWithEpsilon(envelope2, internal_1.GeometryConstants.DEFAULT_EQUAL_EPSILON);
    };
    /**
     * Bound all points in the geometry to be within WGS84 limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #degreesToMeters(Geometry)} and
     * {@link #crop(Geometry, GeometryEnvelope)}.
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    GeometryUtils.boundWGS84 = function (geometry) {
        GeometryUtils.bound(geometry, GeometryUtils.wgs84Envelope());
    };
    /**
     * Bound all points in the geometry to be within WGS84 projection
     * transformable (degrees to meters) limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #degreesToMeters(Geometry)} and
     * {@link #crop(Geometry, GeometryEnvelope)}.
     *
     * @param geometry
     *            geometry
     * @since 1.1.1
     */
    GeometryUtils.boundWGS84Transformable = function (geometry) {
        GeometryUtils.bound(geometry, GeometryUtils.wgs84TransformableEnvelope());
    };
    /**
     * Bound all points in the geometry to be within Web Mercator limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #cropWebMercator(Geometry)}.
     *
     * @param geometry
     *            geometry
     * @since 2.2.0
     */
    GeometryUtils.boundWebMercator = function (geometry) {
        GeometryUtils.bound(geometry, GeometryUtils.webMercatorEnvelope());
    };
    /**
     * Bound all points in the WGS84 geometry to be within degree Web Mercator
     * limits.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #degreesToMeters(Geometry)} and
     * {@link #cropWebMercator(Geometry)}.
     *
     * @param geometry
     *            geometry
     * @since 2.2.0
     */
    GeometryUtils.boundWGS84WithWebMercator = function (geometry) {
        GeometryUtils.bound(geometry, GeometryUtils.wgs84EnvelopeWithWebMercator());
    };
    /**
     * Bound all points in the geometry to be within the geometry envelope.
     * Point x and y values are bounded by the min and max envelope values.
     *
     * To perform a geometry crop using line intersections, see
     * {@link #crop(Geometry, GeometryEnvelope)} (requires geometry in meters).
     *
     * @param geometry
     *            geometry
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.bound = function (geometry, envelope) {
        var e_34, _a;
        var geometryType = geometry.geometryType;
        switch (geometryType) {
            case internal_1.GeometryType.POINT:
                GeometryUtils.boundPoint(geometry, envelope);
                break;
            case internal_1.GeometryType.LINESTRING:
                GeometryUtils.boundLineString(geometry, envelope);
                break;
            case internal_1.GeometryType.POLYGON:
                GeometryUtils.boundPolygon(geometry, envelope);
                break;
            case internal_1.GeometryType.MULTIPOINT:
                GeometryUtils.boundMultiPoint(geometry, envelope);
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                GeometryUtils.boundMultiLineString(geometry, envelope);
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                GeometryUtils.boundMultiPolygon(geometry, envelope);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                GeometryUtils.boundLineString(geometry, envelope);
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                GeometryUtils.boundCompoundCurve(geometry, envelope);
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                var curvePolygon = geometry;
                GeometryUtils.boundCurvePolygon(curvePolygon, envelope);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                GeometryUtils.boundPolyhedralSurface(geometry, envelope);
                break;
            case internal_1.GeometryType.TIN:
                GeometryUtils.boundPolyhedralSurface(geometry, envelope);
                break;
            case internal_1.GeometryType.TRIANGLE:
                GeometryUtils.boundPolygon(geometry, envelope);
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
            case internal_1.GeometryType.MULTICURVE:
            case internal_1.GeometryType.MULTISURFACE:
                var geomCollection = geometry;
                try {
                    for (var _b = __values(geomCollection.geometries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var subGeometry = _c.value;
                        GeometryUtils.bound(subGeometry, envelope);
                    }
                }
                catch (e_34_1) { e_34 = { error: e_34_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_34) throw e_34.error; }
                }
                break;
            default:
                break;
        }
    };
    /**
     * Bound the point by the geometry envelope
     *
     * @param point
     *            point
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundPoint = function (point, envelope) {
        var x = point.x;
        var y = point.y;
        if (x < envelope.minX) {
            point.x = (envelope.minX);
        }
        else if (x > envelope.maxX) {
            point.x = (envelope.maxX);
        }
        if (y < envelope.minY) {
            point.y = (envelope.minY);
        }
        else if (y > envelope.maxY) {
            point.y = (envelope.maxY);
        }
    };
    /**
     * Bound the multi point by the geometry envelope
     *
     * @param multiPoint
     *            multi point
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundMultiPoint = function (multiPoint, envelope) {
        var e_35, _a;
        try {
            for (var _b = __values(multiPoint.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                GeometryUtils.boundPoint(point, envelope);
            }
        }
        catch (e_35_1) { e_35 = { error: e_35_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_35) throw e_35.error; }
        }
    };
    /**
     * Bound the line string by the geometry envelope
     *
     * @param lineString
     *            line string
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundLineString = function (lineString, envelope) {
        var e_36, _a;
        try {
            for (var _b = __values(lineString.points), _c = _b.next(); !_c.done; _c = _b.next()) {
                var point = _c.value;
                GeometryUtils.boundPoint(point, envelope);
            }
        }
        catch (e_36_1) { e_36 = { error: e_36_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_36) throw e_36.error; }
        }
    };
    /**
     * Bound the multi line string by the geometry envelope
     *
     * @param multiLineString
     *            multi line string
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundMultiLineString = function (multiLineString, envelope) {
        var e_37, _a;
        try {
            for (var _b = __values(multiLineString.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                GeometryUtils.boundLineString(lineString, envelope);
            }
        }
        catch (e_37_1) { e_37 = { error: e_37_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_37) throw e_37.error; }
        }
    };
    /**
     * Bound the polygon by the geometry envelope
     *
     * @param polygon
     *            polygon
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundPolygon = function (polygon, envelope) {
        var e_38, _a;
        try {
            for (var _b = __values(polygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                GeometryUtils.boundLineString(ring, envelope);
            }
        }
        catch (e_38_1) { e_38 = { error: e_38_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_38) throw e_38.error; }
        }
    };
    /**
     * Bound the multi polygon by the geometry envelope
     *
     * @param multiPolygon
     *            multi polygon
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundMultiPolygon = function (multiPolygon, envelope) {
        var e_39, _a;
        try {
            for (var _b = __values(multiPolygon.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                GeometryUtils.boundPolygon(polygon, envelope);
            }
        }
        catch (e_39_1) { e_39 = { error: e_39_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_39) throw e_39.error; }
        }
    };
    /**
     * Bound the compound curve by the geometry envelope
     *
     * @param compoundCurve
     *            compound curve
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundCompoundCurve = function (compoundCurve, envelope) {
        var e_40, _a;
        try {
            for (var _b = __values(compoundCurve.lineStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var lineString = _c.value;
                GeometryUtils.boundLineString(lineString, envelope);
            }
        }
        catch (e_40_1) { e_40 = { error: e_40_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_40) throw e_40.error; }
        }
    };
    /**
     * Bound the curve polygon by the geometry envelope
     *
     * @param curvePolygon
     *            curve polygon
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundCurvePolygon = function (curvePolygon, envelope) {
        var e_41, _a;
        try {
            for (var _b = __values(curvePolygon.rings), _c = _b.next(); !_c.done; _c = _b.next()) {
                var ring = _c.value;
                GeometryUtils.bound(ring, envelope);
            }
        }
        catch (e_41_1) { e_41 = { error: e_41_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_41) throw e_41.error; }
        }
    };
    /**
     * Bound the polyhedral surface by the geometry envelope
     *
     * @param polyhedralSurface
     *            polyhedral surface
     * @param envelope
     *            geometry envelope
     * @since 1.1.1
     */
    GeometryUtils.boundPolyhedralSurface = function (polyhedralSurface, envelope) {
        var e_42, _a;
        try {
            for (var _b = __values(polyhedralSurface.polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var polygon = _c.value;
                GeometryUtils.boundPolygon(polygon, envelope);
            }
        }
        catch (e_42_1) { e_42 = { error: e_42_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_42) throw e_42.error; }
        }
    };
    /**
     * Get the parent type hierarchy of the provided geometry type starting with
     * the immediate parent. If the argument is GEOMETRY, an empty list is
     * returned, else the final type in the list will be GEOMETRY.
     * @param geometryType geometry type
     * @return list of increasing parent types
     */
    GeometryUtils.parentHierarchy = function (geometryType) {
        var hierarchy = [];
        var parentType = GeometryUtils.parentType(geometryType);
        while (parentType != null) {
            hierarchy.push(parentType);
            parentType = GeometryUtils.parentType(parentType);
        }
        return hierarchy;
    };
    /**
     * Get the parent Geometry Type of the provided geometry type
     * @param geometryType geometry type
     * @return parent geometry type or null if argument is GEOMETRY (no parent type)
     */
    GeometryUtils.parentType = function (geometryType) {
        var parentType = null;
        switch (geometryType) {
            case internal_1.GeometryType.GEOMETRY:
                break;
            case internal_1.GeometryType.POINT:
                parentType = internal_1.GeometryType.GEOMETRY;
                break;
            case internal_1.GeometryType.LINESTRING:
                parentType = internal_1.GeometryType.CURVE;
                break;
            case internal_1.GeometryType.POLYGON:
                parentType = internal_1.GeometryType.CURVEPOLYGON;
                break;
            case internal_1.GeometryType.MULTIPOINT:
                parentType = internal_1.GeometryType.GEOMETRYCOLLECTION;
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                parentType = internal_1.GeometryType.MULTICURVE;
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                parentType = internal_1.GeometryType.MULTISURFACE;
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
                parentType = internal_1.GeometryType.GEOMETRY;
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                parentType = internal_1.GeometryType.LINESTRING;
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                parentType = internal_1.GeometryType.CURVE;
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                parentType = internal_1.GeometryType.SURFACE;
                break;
            case internal_1.GeometryType.MULTICURVE:
                parentType = internal_1.GeometryType.GEOMETRYCOLLECTION;
                break;
            case internal_1.GeometryType.MULTISURFACE:
                parentType = internal_1.GeometryType.GEOMETRYCOLLECTION;
                break;
            case internal_1.GeometryType.CURVE:
                parentType = internal_1.GeometryType.GEOMETRY;
                break;
            case internal_1.GeometryType.SURFACE:
                parentType = internal_1.GeometryType.GEOMETRY;
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                parentType = internal_1.GeometryType.SURFACE;
                break;
            case internal_1.GeometryType.TIN:
                parentType = internal_1.GeometryType.POLYHEDRALSURFACE;
                break;
            case internal_1.GeometryType.TRIANGLE:
                parentType = internal_1.GeometryType.POLYGON;
                break;
            default:
                throw new internal_1.SFException("Geometry Type not supported: " + geometryType);
        }
        return parentType;
    };
    /**
     * Get the child type hierarchy of the provided geometry type.
     * @param geometryType geometry type
     * @return child type hierarchy, null if no children
     */
    GeometryUtils.childHierarchy = function (geometryType) {
        var e_43, _a;
        var hierarchy = null;
        var childTypes = GeometryUtils.childTypes(geometryType);
        if (childTypes.length > 0) {
            hierarchy = new Map();
            try {
                for (var childTypes_1 = __values(childTypes), childTypes_1_1 = childTypes_1.next(); !childTypes_1_1.done; childTypes_1_1 = childTypes_1.next()) {
                    var childType = childTypes_1_1.value;
                    hierarchy.set(childType, GeometryUtils.childHierarchy(childType));
                }
            }
            catch (e_43_1) { e_43 = { error: e_43_1 }; }
            finally {
                try {
                    if (childTypes_1_1 && !childTypes_1_1.done && (_a = childTypes_1.return)) _a.call(childTypes_1);
                }
                finally { if (e_43) throw e_43.error; }
            }
        }
        return hierarchy;
    };
    /**
     * Get the immediate child Geometry Types of the provided geometry type
     * @param geometryType geometry type
     * @return child geometry types, empty list if no child types
     */
    GeometryUtils.childTypes = function (geometryType) {
        var childTypes = [];
        switch (geometryType) {
            case internal_1.GeometryType.GEOMETRY:
                childTypes.push(internal_1.GeometryType.POINT);
                childTypes.push(internal_1.GeometryType.GEOMETRYCOLLECTION);
                childTypes.push(internal_1.GeometryType.CURVE);
                childTypes.push(internal_1.GeometryType.SURFACE);
                break;
            case internal_1.GeometryType.POINT:
                break;
            case internal_1.GeometryType.LINESTRING:
                childTypes.push(internal_1.GeometryType.CIRCULARSTRING);
                break;
            case internal_1.GeometryType.POLYGON:
                childTypes.push(internal_1.GeometryType.TRIANGLE);
                break;
            case internal_1.GeometryType.MULTIPOINT:
                break;
            case internal_1.GeometryType.MULTILINESTRING:
                break;
            case internal_1.GeometryType.MULTIPOLYGON:
                break;
            case internal_1.GeometryType.GEOMETRYCOLLECTION:
                childTypes.push(internal_1.GeometryType.MULTIPOINT);
                childTypes.push(internal_1.GeometryType.MULTICURVE);
                childTypes.push(internal_1.GeometryType.MULTISURFACE);
                break;
            case internal_1.GeometryType.CIRCULARSTRING:
                break;
            case internal_1.GeometryType.COMPOUNDCURVE:
                break;
            case internal_1.GeometryType.CURVEPOLYGON:
                childTypes.push(internal_1.GeometryType.POLYGON);
                break;
            case internal_1.GeometryType.MULTICURVE:
                childTypes.push(internal_1.GeometryType.MULTILINESTRING);
                break;
            case internal_1.GeometryType.MULTISURFACE:
                childTypes.push(internal_1.GeometryType.MULTIPOLYGON);
                break;
            case internal_1.GeometryType.CURVE:
                childTypes.push(internal_1.GeometryType.LINESTRING);
                childTypes.push(internal_1.GeometryType.COMPOUNDCURVE);
                break;
            case internal_1.GeometryType.SURFACE:
                childTypes.push(internal_1.GeometryType.CURVEPOLYGON);
                childTypes.push(internal_1.GeometryType.POLYHEDRALSURFACE);
                break;
            case internal_1.GeometryType.POLYHEDRALSURFACE:
                childTypes.push(internal_1.GeometryType.TIN);
                break;
            case internal_1.GeometryType.TIN:
                break;
            case internal_1.GeometryType.TRIANGLE:
                break;
            default:
                throw new internal_1.SFException("Geometry Type not supported: " + geometryType);
        }
        return childTypes;
    };
    /**
     * Default epsilon for line tolerance
     */
    GeometryUtils.DEFAULT_EPSILON = 0.000000000000001;
    return GeometryUtils;
}());
exports.GeometryUtils = GeometryUtils;
//# sourceMappingURL=GeometryUtils.js.map