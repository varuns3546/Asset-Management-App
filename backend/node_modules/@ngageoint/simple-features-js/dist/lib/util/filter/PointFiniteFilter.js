"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointFiniteFilter = void 0;
var internal_1 = require("../../internal");
/**
 * Point filter for finite checks on x and y properties, optionally filter on z
 * and m properties and non finite values (NaN or infinity)
 */
var PointFiniteFilter = /** @class */ (function () {
    /**
     * Default Constructor, filter on x and y, allowing only finite values
     */
    function PointFiniteFilter(type, filterZ, filterM) {
        if (filterZ === void 0) { filterZ = false; }
        if (filterM === void 0) { filterM = false; }
        /**
         * Finite Filter type
         */
        this._type = internal_1.FiniteFilterType.FINITE;
        /**
         * Include z values in filtering
         */
        this._filterZ = false;
        /**
         * Include m values in filtering
         */
        this._filterM = false;
        this.setType(type);
        this.setFilterZ(filterZ);
        this.setFilterM(filterM);
    }
    /**
     * Get the finite filter type
     *
     * @return finite filter type
     */
    PointFiniteFilter.prototype.getType = function () {
        return this._type;
    };
    /**
     * Set the finite filter type, null defaults to
     * {@link FiniteFilterType#FINITE}
     *
     * @param type
     *            finite filter type
     */
    PointFiniteFilter.prototype.setType = function (type) {
        this._type = type;
    };
    /**
     * Is filtering for z values enabled?
     *
     * @return true if z filtering
     */
    PointFiniteFilter.prototype.isFilterZ = function () {
        return this._filterZ;
    };
    /**
     * Set the z value filtering mode
     *
     * @param filterZ
     *            true to z filter
     */
    PointFiniteFilter.prototype.setFilterZ = function (filterZ) {
        this._filterZ = filterZ;
    };
    /**
     * Is filtering for m values enabled?
     *
     * @return true if m filtering
     */
    PointFiniteFilter.prototype.isFilterM = function () {
        return this._filterM;
    };
    /**
     * Set the m value filtering mode
     *
     * @param filterM
     *            true to m filter
     */
    PointFiniteFilter.prototype.setFilterM = function (filterM) {
        this._filterM = filterM;
    };
    /**
     * {@inheritDoc}
     */
    PointFiniteFilter.prototype.filter = function (containingType, geometry) {
        return geometry.geometryType != internal_1.GeometryType.POINT || !(geometry instanceof internal_1.Point) || this.filterPoint(geometry);
    };
    /**
     * Filter the point
     *
     * @param point point
     * @return true if passes filter and point should be included
     */
    PointFiniteFilter.prototype.filterPoint = function (point) {
        return this.filterValue(point.x) && this.filterValue(point.y) && this.filterZ(point) && this.filterM(point);
    };
    /**
     * Filter the double value
     * @param value double value
     * @return
     */
    PointFiniteFilter.prototype.filterValue = function (value) {
        var passes;
        switch (this._type) {
            case internal_1.FiniteFilterType.FINITE:
                passes = Number.isFinite(value);
                break;
            case internal_1.FiniteFilterType.FINITE_AND_INFINITE:
                passes = !Number.isNaN(value);
                break;
            case internal_1.FiniteFilterType.FINITE_AND_NAN:
                passes = Number.isFinite(value) || Number.isNaN(value);
                break;
            default:
                throw new internal_1.SFException("Unsupported filter type: " + this._type);
        }
        return passes;
    };
    /**
     * Filter the Z value
     *
     * @param point
     *            point
     * @return true if passes
     */
    PointFiniteFilter.prototype.filterZ = function (point) {
        return !this._filterZ || !point.hasZ || this.filterValue(point.z);
    };
    /**
     * Filter the M value
     *
     * @param point
     *            point
     * @return true if passes
     */
    PointFiniteFilter.prototype.filterM = function (point) {
        return !this._filterM || !point.hasM || this.filterValue(point.m);
    };
    return PointFiniteFilter;
}());
exports.PointFiniteFilter = PointFiniteFilter;
//# sourceMappingURL=PointFiniteFilter.js.map